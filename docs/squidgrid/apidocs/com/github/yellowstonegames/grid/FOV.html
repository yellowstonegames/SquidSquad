<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (22) -->
<title>FOV (squidgrid 4.0.2 API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: com.github.yellowstonegames.grid, class: FOV">
<meta name="generator" content="javadoc/ClassWriter">
<link rel="stylesheet" type="text/css" href="../../../../resource-files/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../resource-files/stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script-files/script.js"></script>
<script type="text/javascript" src="../../../../script-files/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../../script-files/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li>Nested</li>
<li>Field</li>
<li>Constr</li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li>Field</li>
<li>Constr</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">com.github.yellowstonegames.grid</a></div>
<h1 title="Class FOV" class="title">Class FOV</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">com.github.yellowstonegames.grid.FOV</div>
</div>
<section class="class-description" id="class-description">
<div class="horizontal-scroll">
<hr>
<div class="type-signature"><span class="modifiers">public final class </span><span class="element-name type-name-label">FOV</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">This class provides methods for calculating Field of View in grids. Field of
 View (FOV) algorithms determine how much area surrounding a point can be
 seen. They return a 2D array of floats, representing the amount of view
 (typically sight, but perhaps sound, smell, etc.) which the origin has of
 each cell. In the returned 2D array, 1.0f is always "fully seen," while 0.0f
 is always "unseen." Values in between are much more common, and they enable
 this class to be used for lighting effects.
 <br>
 The input resistanceMap is considered the percent of opacity. This resistance
 is on top of the resistance applied from the light spreading out. You can
 obtain a resistance map easily with the <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a>
 method, which uses defaults for common chars used in SquidSquad, but you may
 also want to create a resistance map manually if a given char means something
 very different in your game. This is easy enough to do by looping over all the
 x,y positions in your char[][] map and running a switch statement on each char,
 assigning a float to the same x,y position in a float[][]. The value should
 be between 0.0f (unblocked) for things light passes through, 1.0f (blocked) for
 things light can't pass at all, and possibly other values if you have
 translucent obstacles. There's <a href="#generateSimpleResistances(char%5B%5D%5B%5D)"><code>generateSimpleResistances(char[][])</code></a> as
 well, which only returns 1.0f (fully blocked) or 0.0f (passable), and 3x3 subcell
 variants, which produce a resistance map that is 3 times wider and 3 times
 taller than the input map. The subcell variants have especially useful behavior
 when using maps with box-drawing characters, since these 3x3 resistance maps
 will line up blocking cells to where a box-drawing line is.
 <br>
 The returned light map is considered the percent of light in the cells.
 <br>
 All implementations for FOV here (that is, Ripple FOV and Shadow FOV) provide
 percentage levels for partially-lit or partially-seen cells. This leads to a
 straightforward implementation of soft lighting using an FOV result -- just
 mix the background or floor color of a cell, however you represent it, with
 a very light color (like pastel yellow), with the percentage of the light
 color to mix in equal to the percent of light in the FOV map.
 <br>
 All solvers perform bounds checking so solid borders in the map are not
 required.
 <br>
 For calculating FOV maps, this class only provides static methods, which take
 a light 2D array as an argument and edit it in-place. The Ripple methods
 <a href="#reuseRippleFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,int,float,com.github.yellowstonegames.grid.Radius)"><code>reuseRippleFOV(float[][], float[][], int, int, int, float, Radius)</code></a>
 and <a href="#reuseRippleFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,int,float,com.github.yellowstonegames.grid.Radius,float,float)"><code>reuseRippleFOV(float[][], float[][], int, int, int, float, Radius, float, float)</code></a>
 use internal static state, resetting it on each call; this makes them
 ineligible for use in multithreaded code. The other methods use Shadow FOV,
 and are potentially usable in multithreaded code.
 <br>
 Static methods are provided to add together FOV maps in the simple way
 (disregarding visibility of distant FOV from a given cell), or the more
 practical way for roguelikes (where a cell needs to be within line-of-sight
 in the first place for a distant light to illuminate it). The second method
 relies on an LOS map, which is essentially the same as a very-high-radius
 FOV map and can be easily obtained with calculateLOSMap(). The simple way uses
 <a href="#addFOVs(float%5B%5D%5B%5D...)"><code>addFOVs(float[][]...)</code></a> or <a href="#addFOVsInto(float%5B%5D%5B%5D,float%5B%5D%5B%5D...)"><code>addFOVsInto(float[][], float[][]...)</code></a>,
 while the way that respects LOS uses <a href="#mixVisibleFOVs(float%5B%5D%5B%5D,float%5B%5D%5B%5D...)"><code>mixVisibleFOVs(float[][], float[][]...)</code></a>
 or <a href="#mixVisibleFOVsInto(float%5B%5D%5B%5D,float%5B%5D%5B%5D,float%5B%5D%5B%5D...)"><code>mixVisibleFOVsInto(float[][], float[][], float[][]...)</code></a>.
 <br>
 If you want to iterate through cells that are visible in a float[][] returned
 by FOV, you can pass that float[][] to <a href="#cellsByDescendingValue(float%5B%5D%5B%5D)"><code>cellsByDescendingValue(float[][])</code></a>
 and iterate over the returned map's <code>ObjectFloatOrderedMap.entrySet()</code> or
 <code>ObjectFloatOrderedMap.order()</code>. These approaches will start iteration at the
 highest-value cell and continue to lower and lower values. You can also reuse an
 existing CoordFloatOrderedMap using <a href="#fillCellsByDescendingValue(float%5B%5D%5B%5D,com.github.yellowstonegames.grid.CoordFloatOrderedMap)"><code>fillCellsByDescendingValue(float[][], CoordFloatOrderedMap)</code></a>,
 which is a better choice than cellsByDescendingValue() if you call it every frame.</div>
</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#addFOVs(float%5B%5D%5B%5D...)" class="member-name-link">addFOVs</a><wbr>(float[][]...&nbsp;grids)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Adds multiple FOV grids together in the simplest way possible; does not check line-of-sight between FOV grids.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#addFOVs(java.lang.Iterable)" class="member-name-link">addFOVs</a><wbr>(<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Iterable.html" title="class or interface in java.lang" class="external-link">Iterable</a>&lt;float[][]&gt;&nbsp;grids)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Adds multiple FOV grids together in the simplest way possible; does not check line-of-sight between FOV grids.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#addFOVsInto(float%5B%5D%5B%5D,float%5B%5D%5B%5D)" class="member-name-link">addFOVsInto</a><wbr>(float[][]&nbsp;basis,
 float[][]&nbsp;addend)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Adds an FOV grid to another in the simplest way possible; does not check line-of-sight between FOV grids.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#addFOVsInto(float%5B%5D%5B%5D,float%5B%5D%5B%5D...)" class="member-name-link">addFOVsInto</a><wbr>(float[][]&nbsp;basis,
 float[][]...&nbsp;grids)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Adds multiple FOV grids to basis cell-by-cell, modifying basis; does not check line-of-sight between FOV grids.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#bouncingLine(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,float)" class="member-name-link">bouncingLine</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;distance,
 float&nbsp;angle)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Reuses the existing light 2D array and fills it with a straight-line bouncing path of light that reflects its way
 through the given resistanceMap from startX, startY until it uses up the given distance.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="CoordFloatOrderedMap.html" title="class in com.github.yellowstonegames.grid">CoordFloatOrderedMap</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#cellsByDescendingValue(float%5B%5D%5B%5D)" class="member-name-link">cellsByDescendingValue</a><wbr>(float[][]&nbsp;fovGrid)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a typical FOV grid produced by <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int)"><code>reuseFOV(float[][], float[][], int, int)</code></a>,
 <a href="#reuseRippleFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)"><code>reuseRippleFOV(float[][], float[][], int, int, float, Radius)</code></a>, or a similar method, this gets a
 <a href="CoordFloatOrderedMap.html" title="class in com.github.yellowstonegames.grid"><code>CoordFloatOrderedMap</code></a> containing only the visible Coord cells as keys, associated with their visibility
 levels, and ordered so the most-visible cell (typically where the viewer is) is first in the iteration order.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="CoordFloatOrderedMap.html" title="class in com.github.yellowstonegames.grid">CoordFloatOrderedMap</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#fillCellsByDescendingValue(float%5B%5D%5B%5D,com.github.yellowstonegames.grid.CoordFloatOrderedMap)" class="member-name-link">fillCellsByDescendingValue</a><wbr>(float[][]&nbsp;fovGrid,
 <a href="CoordFloatOrderedMap.html" title="class in com.github.yellowstonegames.grid">CoordFloatOrderedMap</a>&nbsp;modifying)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a typical FOV map produced by <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int)"><code>reuseFOV(float[][], float[][], int, int)</code></a>,
 <a href="#reuseRippleFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)"><code>reuseRippleFOV(float[][], float[][], int, int, float, Radius)</code></a>, or a similar method and a
 <a href="CoordFloatOrderedMap.html" title="class in com.github.yellowstonegames.grid"><code>CoordFloatOrderedMap</code></a> <code>modifying</code> to clear and reuse in-place, this fills <code>modifying</code>
 with only the visible Coord cells as keys, associated with their visibility
 levels, and ordered so the most-visible cell (typically where the viewer is) is first in the iteration order.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#fillResistancesInto(char%5B%5D%5B%5D,float%5B%5D%5B%5D)" class="member-name-link">fillResistancesInto</a><wbr>(char[][]&nbsp;grid,
 float[][]&nbsp;into)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a char[][] for the local area and a float[][] with the same dimensions as the chars, fills the float[][] so
 it can be used with most of the methods in FOV, like <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float)"><code>reuseFOV(float[][], float[][], int, int, float)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#fillSimpleResistancesInto(char%5B%5D%5B%5D,float%5B%5D%5B%5D)" class="member-name-link">fillSimpleResistancesInto</a><wbr>(char[][]&nbsp;grid,
 float[][]&nbsp;into)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a char[][] for the local area and a float[][] with the same dimensions as the chars, fills the float[][] so it can
 be used with most of the methods in FOV, like <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float)"><code>reuseFOV(float[][], float[][], int, int, float)</code></a>, but does
 not treat any cells as partly transparent, only fully-blocking or fully-permitting light.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#generateResistances(char%5B%5D%5B%5D)" class="member-name-link">generateResistances</a><wbr>(char[][]&nbsp;map)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a char[][] for the local area, produces a float[][] that can be used with most of the methods in FOV, like
 <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float)"><code>reuseFOV(float[][], float[][], int, int, float)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#generateResistances3x3(char%5B%5D%5B%5D)" class="member-name-link">generateResistances3x3</a><wbr>(char[][]&nbsp;grid)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a char[][] for the local area that should use box drawing characters, produces a float[][] with triple
 width and triple height that can be used with FOV methods like
 <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float)"><code>reuseFOV(float[][], float[][], int, int, float)</code></a> in classes that use subcell lighting.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#generateSimpleResistances(char%5B%5D%5B%5D)" class="member-name-link">generateSimpleResistances</a><wbr>(char[][]&nbsp;grid)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a char[][] for the local area, produces a float[][] that can be used with any FOV methods that expect a
 resistance grid (like <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float)"><code>reuseFOV(float[][], float[][], int, int, float)</code></a>), but does not treat
 any cells as partly transparent, only fully-blocking or fully-permitting light.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#generateSimpleResistances3x3(char%5B%5D%5B%5D)" class="member-name-link">generateSimpleResistances3x3</a><wbr>(char[][]&nbsp;grid)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a char[][] for the local area that should use box drawing characters, produces a float[][] with triple
 width and triple height that can be used with FOV's methods that expect a resistance grid (like
 <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float)"><code>reuseFOV(float[][], float[][], int, int, float)</code></a>) in classes that use subcell lighting.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#generateSoundResistances(char%5B%5D%5B%5D)" class="member-name-link">generateSoundResistances</a><wbr>(char[][]&nbsp;grid)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a char[][] for the local area, produces a float[][] that can be used with the sound-related methods here,
 allowing sound to pass through thin-enough walls and doors.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#mixVisibleFOVs(float%5B%5D%5B%5D,float%5B%5D%5B%5D...)" class="member-name-link">mixVisibleFOVs</a><wbr>(float[][]&nbsp;losGrid,
 float[][]...&nbsp;grids)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Adds together multiple FOV grids, but only adds to a position if it is visible in the given LOS grid.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#mixVisibleFOVs(float%5B%5D%5B%5D,java.lang.Iterable)" class="member-name-link">mixVisibleFOVs</a><wbr>(float[][]&nbsp;losGrid,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Iterable.html" title="class or interface in java.lang" class="external-link">Iterable</a>&lt;float[][]&gt;&nbsp;grids)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Adds together multiple FOV grids, but only adds to a position if it is visible in the given LOS grid.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#mixVisibleFOVsInto(float%5B%5D%5B%5D,float%5B%5D%5B%5D,float%5B%5D%5B%5D...)" class="member-name-link">mixVisibleFOVsInto</a><wbr>(float[][]&nbsp;losGrid,
 float[][]&nbsp;basis,
 float[][]...&nbsp;grids)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Adds together multiple FOV grids, but only adds to a position if it is visible in the given LOS grid.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#resistance(char)" class="member-name-link">resistance</a><wbr>(char&nbsp;cell)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a single char, returns what <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a> or
 <a href="#fillResistancesInto(char%5B%5D%5B%5D,float%5B%5D%5B%5D)"><code>fillResistancesInto(char[][], float[][])</code></a> would consider as its light resistance value.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int)" class="member-name-link">reuseFOV</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startx,
 int&nbsp;starty)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float)" class="member-name-link">reuseFOV</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startx,
 int&nbsp;starty,
 float&nbsp;radius)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)" class="member-name-link">reuseFOV</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius,float,float)" class="member-name-link">reuseFOV</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;span)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates, lighting at the given angle in degrees and covering a span
 centered on that angle, also in degrees.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius,float,float,float,float,float,float)" class="member-name-link">reuseFOV</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;forward,
 float&nbsp;sideForward,
 float&nbsp;side,
 float&nbsp;sideBack,
 float&nbsp;back)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates, lighting with the view "pointed at" the given <code>angle</code> in degrees,
 extending to different ranges based on the direction the light is traveling.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseFOVDeg(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius,float,float)" class="member-name-link">reuseFOVDeg</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;span)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates, lighting at the given angle in degrees and covering a span
 centered on that angle, also in degrees.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseFOVDeg(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius,float,float,float,float,float,float)" class="member-name-link">reuseFOVDeg</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;forward,
 float&nbsp;sideForward,
 float&nbsp;side,
 float&nbsp;sideBack,
 float&nbsp;back)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates, lighting with the view "pointed at" the given <code>angle</code> in degrees,
 extending to different ranges based on the direction the light is traveling.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseFOVOrtho(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)" class="member-name-link">reuseFOVOrtho</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates the symmetrical Field Of View for the provided resistanceMap from the given x, y viewer
 coordinates.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseFOVRad(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius,float,float)" class="member-name-link">reuseFOVRad</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;span)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates, lighting at the given angle in radians and covering a span
 centered on that angle, also in radians.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseFOVRad(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius,float,float,float,float,float,float)" class="member-name-link">reuseFOVRad</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;forward,
 float&nbsp;sideForward,
 float&nbsp;side,
 float&nbsp;sideBack,
 float&nbsp;back)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates, lighting with the view "pointed at" the given <code>angle</code> in radians,
 extending to different ranges based on the direction the light is traveling.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseFOVSymmetrical(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)" class="member-name-link">reuseFOVSymmetrical</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates the symmetrical Field Of View for the provided resistanceMap from the given x, y viewer
 coordinates.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseFOVTurns(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius,float,float)" class="member-name-link">reuseFOVTurns</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;span)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates, lighting at the given angle in turns and covering a span
 centered on that angle, also in turns.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseFOVTurns(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius,float,float,float,float,float,float)" class="member-name-link">reuseFOVTurns</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;forward,
 float&nbsp;sideForward,
 float&nbsp;side,
 float&nbsp;sideBack,
 float&nbsp;back)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates, lighting with the view "pointed at" the given <code>angle</code> in turns,
 extending to different ranges based on the direction the light is traveling.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseLOS(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int)" class="member-name-link">reuseLOS</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates which cells have line of sight from the given x, y coordinates.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseLOS(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,int,int,int,int)" class="member-name-link">reuseLOS</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 int&nbsp;minX,
 int&nbsp;minY,
 int&nbsp;maxX,
 int&nbsp;maxY)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates which cells have line of sight from the given x, y coordinates.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="Region.html" title="class in com.github.yellowstonegames.grid">Region</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseLOS(com.github.yellowstonegames.grid.Region,com.github.yellowstonegames.grid.Region,int,int)" class="member-name-link">reuseLOS</a><wbr>(<a href="Region.html" title="class in com.github.yellowstonegames.grid">Region</a>&nbsp;blockingMap,
 <a href="Region.html" title="class in com.github.yellowstonegames.grid">Region</a>&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates which cells have line of sight from the given x, y coordinates.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="Region.html" title="class in com.github.yellowstonegames.grid">Region</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseLOS(com.github.yellowstonegames.grid.Region,com.github.yellowstonegames.grid.Region,int,int,int,int,int,int)" class="member-name-link">reuseLOS</a><wbr>(<a href="Region.html" title="class in com.github.yellowstonegames.grid">Region</a>&nbsp;blockingMap,
 <a href="Region.html" title="class in com.github.yellowstonegames.grid">Region</a>&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 int&nbsp;minX,
 int&nbsp;minY,
 int&nbsp;maxX,
 int&nbsp;maxY)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates which cells have line of sight from the given x, y coordinates.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseRippleFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)" class="member-name-link">reuseRippleFOV</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;x,
 int&nbsp;y,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Like the <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)"><code>reuseFOV(float[][], float[][], int, int, float, Radius)</code></a> method, but this uses Ripple FOV
 with a tightness/looseness of 2.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseRippleFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,int,float,com.github.yellowstonegames.grid.Radius)" class="member-name-link">reuseRippleFOV</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;rippleLooseness,
 int&nbsp;x,
 int&nbsp;y,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Like the <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)"><code>reuseFOV(float[][], float[][], int, int, float, Radius)</code></a> method, but this uses Ripple FOV
 with a configurable tightness/looseness (between 1, tightest, and 6, loosest).</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseRippleFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,int,float,com.github.yellowstonegames.grid.Radius,float,float)" class="member-name-link">reuseRippleFOV</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;rippleLooseness,
 int&nbsp;x,
 int&nbsp;y,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;span)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Like the <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius,float,float)"><code>reuseFOV(float[][], float[][], int, int, float, Radius, float, float)</code></a> method, but this
 uses Ripple FOV with a configurable tightness/looseness (between 1, tightest, and 6, loosest).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float[][]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#reuseSoundField(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)" class="member-name-link">reuseSoundField</a><wbr>(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;sound,
 int&nbsp;x,
 int&nbsp;y,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Like the <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)"><code>reuseFOV(float[][], float[][], int, int, float, Radius)</code></a> method, but this is meant for sound
 rather than light, and so uses Ripple FOV with maximum looseness, and expects a sound resistance map rather than
 a light one.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#simpleResistance(char)" class="member-name-link">simpleResistance</a><wbr>(char&nbsp;cell)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a single char, returns what <a href="#generateSimpleResistances(char%5B%5D%5B%5D)"><code>generateSimpleResistances(char[][])</code></a> or
 <a href="#fillSimpleResistancesInto(char%5B%5D%5B%5D,float%5B%5D%5B%5D)"><code>fillSimpleResistancesInto(char[][], float[][])</code></a> would consider as its light resistance value.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="reuseFOV(float[][],float[][],int,int)">
<h3>reuseFOV</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseFOV</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startx,
 int&nbsp;starty)</span></div>
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates. Assigns to, and returns, a light map where the values
 represent a percentage of fully lit. Always uses Shadow FOV,
 which allows this method to be static since it doesn't need to keep any
 state around, and can reuse the state the user gives it via the
 <code>light</code> parameter.  The values in light are always cleared before
 this is run, because prior state can make this give incorrect results.
 <br>
 The starting point for the calculation is considered to be at the center
 of the origin cell. Radius determinations based on Euclidean
 calculations. The light will be treated as having infinite possible
 radius.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - the grid of cells to calculate on; the kind made by <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a></dd>
<dd><code>light</code> - a non-null 2D float array that will have its contents overwritten, modified, and returned</dd>
<dd><code>startx</code> - the horizontal component of the starting location</dd>
<dd><code>starty</code> - the vertical component of the starting location</dd>
<dt>Returns:</dt>
<dd>the computed light grid (the same as <code>light</code>)</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseFOV(float[][],float[][],int,int,float)">
<h3>reuseFOV</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseFOV</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startx,
 int&nbsp;starty,
 float&nbsp;radius)</span></div>
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates. Assigns to, and returns, a light map where the values
 represent a percentage of fully lit. Always uses Shadow FOV,
 which allows this method to be static since it doesn't need to keep any
 state around, and can reuse the state the user gives it via the
 <code>light</code> parameter. The values in light are always cleared before
 this is run, because prior state can make this give incorrect results.
 <br>
 The starting point for the calculation is considered to be at the center
 of the origin cell. Radius determinations based on Euclidean
 calculations.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - the grid of cells to calculate on; the kind made by <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a></dd>
<dd><code>startx</code> - the horizontal component of the starting location</dd>
<dd><code>starty</code> - the vertical component of the starting location</dd>
<dd><code>radius</code> - the distance the light will extend to</dd>
<dt>Returns:</dt>
<dd>the computed light grid</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseFOV(float[][],float[][],int,int,float,com.github.yellowstonegames.grid.Radius)">
<h3>reuseFOV</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseFOV</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique)</span></div>
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates. Assigns to, and returns, a light map where the values
 represent a percentage of fully lit. Always uses Shadow FOV,
 which allows this method to be static since it doesn't need to keep any
 state around, and can reuse the state the user gives it via the
 <code>light</code> parameter. The values in light are always cleared before
 this is run, because prior state can make this give incorrect results.
 <br>
 The starting point for the calculation is considered to be at the center
 of the origin cell. Radius determinations are determined by the provided
 RadiusStrategy.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - the grid of cells to calculate on; the kind made by <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a></dd>
<dd><code>light</code> - the grid of cells to assign to, which will be cleared; 0f means "unlit" and 1f means "fully lit"</dd>
<dd><code>startX</code> - the horizontal component of the starting location</dd>
<dd><code>startY</code> - the vertical component of the starting location</dd>
<dd><code>radius</code> - the distance the light will extend to</dd>
<dd><code>radiusTechnique</code> - a Radius enum constant, such as <a href="Radius.html#CIRCLE"><code>Radius.CIRCLE</code></a>, that provides the shape of the FOV</dd>
<dt>Returns:</dt>
<dd>the computed light grid, which is the same 2D array as <code>light</code></dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseFOVSymmetrical(float[][],float[][],int,int,float,com.github.yellowstonegames.grid.Radius)">
<h3>reuseFOVSymmetrical</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseFOVSymmetrical</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique)</span></div>
<div class="block">Calculates the symmetrical Field Of View for the provided resistanceMap from the given x, y viewer
 coordinates. Assigns to, and returns, a light map where the values represent a percentage of fully
 lit. If any cell in the returned light map is greater than 0, then both the viewer can see that cell,
 and anyone in that cell can see the viewer (if they have sufficient viewing range). Always uses Shadow
 FOV, and can reuse the state the user gives it via the <code>light</code> parameter. The values in light
 are always cleared before this is run, because prior state can make this give incorrect results. This
 evaluates if the viewer and target cell can mutually see each other using a mirrored call to
 (simplified) single-octant Shadow FOV.
 <br>
 The starting point for the calculation is considered to be at the center
 of the origin cell. Radius determinations are determined by the provided
 RadiusStrategy.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - the grid of cells to calculate on; the kind made by <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a></dd>
<dd><code>light</code> - the grid of cells to assign to, which will be cleared; 0f means "unlit" and 1f means "fully lit"</dd>
<dd><code>startX</code> - the horizontal component of the starting location</dd>
<dd><code>startY</code> - the vertical component of the starting location</dd>
<dd><code>radius</code> - the distance the light will extend to</dd>
<dd><code>radiusTechnique</code> - a Radius enum constant, such as <a href="Radius.html#CIRCLE"><code>Radius.CIRCLE</code></a>, that provides the shape of the FOV</dd>
<dt>Returns:</dt>
<dd>the computed light grid, which is the same 2D array as <code>light</code></dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseLOS(float[][],float[][],int,int)">
<h3>reuseLOS</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseLOS</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY)</span></div>
<div class="block">Calculates which cells have line of sight from the given x, y coordinates.
 Assigns to, and returns, a light map where the values
 are always either 0.0f for "not in line of sight" or 1.0f for "in line of
 sight," which doesn't mean a cell is actually visible if there's no light
 in that cell. Always uses Shadow FOV, which allows this method to
 be static since it doesn't need to keep any state around, and can reuse the
 state the user gives it via the <code>light</code> parameter. The values in light
 are always cleared before this is run, because prior state can make this give
 incorrect results. The given <code>resistanceMap</code> only considers cells to
 block light if they have values of 1.0f or greater.
 <br>
 The starting point for the calculation is considered to be at the center
 of the origin cell. Radius determinations are pretty much irrelevant because
 the distance doesn't matter, only the presence of a clear line, but this uses
 <a href="Radius.html#SQUARE"><code>Radius.SQUARE</code></a> if it matters.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - the grid of cells to calculate on; the kind made by <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a></dd>
<dd><code>light</code> - the grid of cells to assign to; may have existing values, and 0.0f is used to mean "no line"</dd>
<dd><code>startX</code> - the horizontal component of the starting location</dd>
<dd><code>startY</code> - the vertical component of the starting location</dd>
<dt>Returns:</dt>
<dd>the computed light grid, which is the same 2D array as the value assigned to <code>light</code></dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseLOS(float[][],float[][],int,int,int,int,int,int)">
<h3>reuseLOS</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseLOS</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 int&nbsp;minX,
 int&nbsp;minY,
 int&nbsp;maxX,
 int&nbsp;maxY)</span></div>
<div class="block">Calculates which cells have line of sight from the given x, y coordinates.
 Assigns to, and returns, a light map where the values
 are always either 0.0f for "not in line of sight" or 1.0f for "in line of
 sight," which doesn't mean a cell is actually visible if there's no light
 in that cell. Always uses Shadow FOV, which allows this method to
 be static since it doesn't need to keep any state around, and can reuse the
 state the user gives it via the <code>light</code> parameter. The values in light
 are always cleared before this is run, because prior state can make this give
 incorrect results. The given <code>resistanceMap</code> only considers cells to
 block light if they have values of 1.0f or greater.
 <br>
 The starting point for the calculation is considered to be at the center
 of the origin cell. Radius determinations are pretty much irrelevant because
 the distance doesn't matter, only the presence of a clear line, but this uses
 <a href="Radius.html#SQUARE"><code>Radius.SQUARE</code></a> if it matters.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - the grid of cells to calculate on; the kind made by <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a></dd>
<dd><code>light</code> - the grid of cells to assign to; may have existing values, and 0.0f is used to mean "no line"</dd>
<dd><code>startX</code> - the horizontal component of the starting location</dd>
<dd><code>startY</code> - the vertical component of the starting location</dd>
<dd><code>minX</code> - inclusive lowest x position to assign to or process in <code>light</code></dd>
<dd><code>minY</code> - inclusive lowest y position to assign to or process in <code>light</code></dd>
<dd><code>maxX</code> - exclusive highest x position to assign to or process in <code>light</code></dd>
<dd><code>maxY</code> - exclusive highest y position to assign to or process in <code>light</code></dd>
<dt>Returns:</dt>
<dd>the computed light grid, which is the same 2D array as the value assigned to <code>light</code></dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseLOS(com.github.yellowstonegames.grid.Region,com.github.yellowstonegames.grid.Region,int,int)">
<h3>reuseLOS</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="Region.html" title="class in com.github.yellowstonegames.grid">Region</a></span>&nbsp;<span class="element-name">reuseLOS</span><wbr><span class="parameters">(<a href="Region.html" title="class in com.github.yellowstonegames.grid">Region</a>&nbsp;blockingMap,
 <a href="Region.html" title="class in com.github.yellowstonegames.grid">Region</a>&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY)</span></div>
<div class="block">Calculates which cells have line of sight from the given x, y coordinates.
 Assigns to, and returns, a light Region where the false or "off" indicates
 "not in line of sight" and true or "on" indicated "in line of sight,"
 though this doesn't mean a cell is actually visible if there's no light
 in that cell. Always uses Shadow FOV, which allows this method to
 be static since it doesn't need to keep any state around, and can reuse the
 state the user gives it via the <code>light</code> parameter. The values in light
 are always cleared before this is run, because prior state can make this give
 incorrect results. The given <code>blockingMap</code> only considers cells to
 block light if they are true or "on".
 <br>
 The starting point for the calculation is considered to be at the center
 of the origin cell.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>blockingMap</code> - the grid of which cells block light ("on" cells are blocking)</dd>
<dd><code>light</code> - the grid of cells to assign to; will be cleared before modifying</dd>
<dd><code>startX</code> - the horizontal component of the starting location</dd>
<dd><code>startY</code> - the vertical component of the starting location</dd>
<dt>Returns:</dt>
<dd>the computed light grid, which is the same 2D array as the value assigned to <code>light</code></dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseLOS(com.github.yellowstonegames.grid.Region,com.github.yellowstonegames.grid.Region,int,int,int,int,int,int)">
<h3>reuseLOS</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="Region.html" title="class in com.github.yellowstonegames.grid">Region</a></span>&nbsp;<span class="element-name">reuseLOS</span><wbr><span class="parameters">(<a href="Region.html" title="class in com.github.yellowstonegames.grid">Region</a>&nbsp;blockingMap,
 <a href="Region.html" title="class in com.github.yellowstonegames.grid">Region</a>&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 int&nbsp;minX,
 int&nbsp;minY,
 int&nbsp;maxX,
 int&nbsp;maxY)</span></div>
<div class="block">Calculates which cells have line of sight from the given x, y coordinates.
 Assigns to, and returns, a light Region where the false or "off" indicates
 "not in line of sight" and true or "on" indicated "in line of sight,"
 though this doesn't mean a cell is actually visible if there's no light
 in that cell. Always uses Shadow FOV, which allows this method to
 be static since it doesn't need to keep any state around, and can reuse the
 state the user gives it via the <code>light</code> parameter. The values in light
 are always cleared before this is run, because prior state can make this give
 incorrect results. The given <code>blockingMap</code> only considers cells to
 block light if they are true or "on".
 <br>
 The starting point for the calculation is considered to be at the center
 of the origin cell.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>blockingMap</code> - the grid of which cells block light ("on" cells are blocking)</dd>
<dd><code>light</code> - the grid of cells to assign to; will be cleared before modifying</dd>
<dd><code>startX</code> - the horizontal component of the starting location</dd>
<dd><code>startY</code> - the vertical component of the starting location</dd>
<dd><code>minX</code> - inclusive lowest x position to assign to or process in <code>light</code></dd>
<dd><code>minY</code> - inclusive lowest y position to assign to or process in <code>light</code></dd>
<dd><code>maxX</code> - exclusive highest x position to assign to or process in <code>light</code></dd>
<dd><code>maxY</code> - exclusive highest y position to assign to or process in <code>light</code></dd>
<dt>Returns:</dt>
<dd>the computed light grid, which is the same 2D array as the value assigned to <code>light</code></dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseFOV(float[][],float[][],int,int,float,com.github.yellowstonegames.grid.Radius,float,float)">
<h3>reuseFOV</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseFOV</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;span)</span></div>
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates, lighting at the given angle in degrees and covering a span
 centered on that angle, also in degrees. Assigns to, and returns, a light
 map where the values represent a percentage of fully lit. Always uses
 Shadow FOV, which allows this method to be static since it doesn't
 need to keep any state around, and can reuse the state the user gives it
 via the <code>light</code> parameter. The values in light are cleared before
 this is run, because prior state can make this give incorrect results.
 <br>
 The starting point for the calculation is considered to be at the center
 of the origin cell. Radius determinations are determined by the provided
 RadiusStrategy.  A conical section of FOV is lit by this method if
 span is greater than 0.
 <br>
 This is an alias for <a href="#reuseFOVDeg(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius,float,float)"><code>reuseFOVDeg(float[][], float[][], int, int, float, Radius, float, float)</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - the grid of cells to calculate on; the kind made by <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a></dd>
<dd><code>light</code> - the grid of cells to assign to; may have existing values, and 0.0f is used to mean "unlit"</dd>
<dd><code>startX</code> - the horizontal component of the starting location</dd>
<dd><code>startY</code> - the vertical component of the starting location</dd>
<dd><code>radius</code> - the distance the light will extend to</dd>
<dd><code>radiusTechnique</code> - provides a means to shape the FOV by changing distance calculation (circle, square, etc.)</dd>
<dd><code>angle</code> - the angle in degrees that will be the center of the FOV cone, 0 points right</dd>
<dd><code>span</code> - the angle in degrees that measures the full arc contained in the FOV cone</dd>
<dt>Returns:</dt>
<dd>the computed light grid</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseFOVRad(float[][],float[][],int,int,float,com.github.yellowstonegames.grid.Radius,float,float)">
<h3>reuseFOVRad</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseFOVRad</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;span)</span></div>
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates, lighting at the given angle in radians and covering a span
 centered on that angle, also in radians. Assigns to, and returns, a light
 map where the values represent a percentage of fully lit. Always uses
 Shadow FOV, which allows this method to be static since it doesn't
 need to keep any state around, and can reuse the state the user gives it
 via the <code>light</code> parameter. The values in light are cleared before
 this is run, because prior state can make this give incorrect results.
 <br>
 The starting point for the calculation is considered to be at the center
 of the origin cell. Radius determinations are determined by the provided
 RadiusStrategy.  A conical section of FOV is lit by this method if
 span is greater than 0.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - the grid of cells to calculate on; the kind made by <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a></dd>
<dd><code>light</code> - the grid of cells to assign to; may have existing values, and 0.0f is used to mean "unlit"</dd>
<dd><code>startX</code> - the horizontal component of the starting location</dd>
<dd><code>startY</code> - the vertical component of the starting location</dd>
<dd><code>radius</code> - the distance the light will extend to</dd>
<dd><code>radiusTechnique</code> - provides a means to shape the FOV by changing distance calculation (circle, square, etc.)</dd>
<dd><code>angle</code> - the angle in radians that will be the center of the FOV cone, 0 points right</dd>
<dd><code>span</code> - the angle in radians that measures the full arc contained in the FOV cone</dd>
<dt>Returns:</dt>
<dd>the computed light grid</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseFOVDeg(float[][],float[][],int,int,float,com.github.yellowstonegames.grid.Radius,float,float)">
<h3>reuseFOVDeg</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseFOVDeg</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;span)</span></div>
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates, lighting at the given angle in degrees and covering a span
 centered on that angle, also in degrees. Assigns to, and returns, a light
 map where the values represent a percentage of fully lit. Always uses
 Shadow FOV, which allows this method to be static since it doesn't
 need to keep any state around, and can reuse the state the user gives it
 via the <code>light</code> parameter. The values in light are cleared before
 this is run, because prior state can make this give incorrect results.
 <br>
 The starting point for the calculation is considered to be at the center
 of the origin cell. Radius determinations are determined by the provided
 RadiusStrategy.  A conical section of FOV is lit by this method if
 span is greater than 0.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - the grid of cells to calculate on; the kind made by <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a></dd>
<dd><code>light</code> - the grid of cells to assign to; may have existing values, and 0.0f is used to mean "unlit"</dd>
<dd><code>startX</code> - the horizontal component of the starting location</dd>
<dd><code>startY</code> - the vertical component of the starting location</dd>
<dd><code>radius</code> - the distance the light will extend to</dd>
<dd><code>radiusTechnique</code> - provides a means to shape the FOV by changing distance calculation (circle, square, etc.)</dd>
<dd><code>angle</code> - the angle in degrees that will be the center of the FOV cone, 0 points right</dd>
<dd><code>span</code> - the angle in degrees that measures the full arc contained in the FOV cone</dd>
<dt>Returns:</dt>
<dd>the computed light grid</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseFOVTurns(float[][],float[][],int,int,float,com.github.yellowstonegames.grid.Radius,float,float)">
<h3>reuseFOVTurns</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseFOVTurns</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;span)</span></div>
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates, lighting at the given angle in turns and covering a span
 centered on that angle, also in turns. Assigns to, and returns, a light
 map where the values represent a percentage of fully lit. Always uses
 Shadow FOV, which allows this method to be static since it doesn't
 need to keep any state around, and can reuse the state the user gives it
 via the <code>light</code> parameter. The values in light are cleared before
 this is run, because prior state can make this give incorrect results.
 <br>
 The starting point for the calculation is considered to be at the center
 of the origin cell. Radius determinations are determined by the provided
 RadiusStrategy.  A conical section of FOV is lit by this method if
 span is greater than 0.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - the grid of cells to calculate on; the kind made by <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a></dd>
<dd><code>light</code> - the grid of cells to assign to; may have existing values, and 0.0f is used to mean "unlit"</dd>
<dd><code>startX</code> - the horizontal component of the starting location</dd>
<dd><code>startY</code> - the vertical component of the starting location</dd>
<dd><code>radius</code> - the distance the light will extend to</dd>
<dd><code>radiusTechnique</code> - provides a means to shape the FOV by changing distance calculation (circle, square, etc.)</dd>
<dd><code>angle</code> - the angle in turns that will be the center of the FOV cone, 0 points right</dd>
<dd><code>span</code> - the angle in turns that measures the full arc contained in the FOV cone</dd>
<dt>Returns:</dt>
<dd>the computed light grid</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseRippleFOV(float[][],float[][],int,int,float,com.github.yellowstonegames.grid.Radius)">
<h3>reuseRippleFOV</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseRippleFOV</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;x,
 int&nbsp;y,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique)</span></div>
<div class="block">Like the <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)"><code>reuseFOV(float[][], float[][], int, int, float, Radius)</code></a> method, but this uses Ripple FOV
 with a tightness/looseness of 2. Other parameters are similar; you
 can get a resistance map from <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a>, <code>light</code> will be modified and returned
 (it will be overwritten, but its size should be the same as the resistance map), there's a starting x,y position,
 a radius in cells, and a <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid"><code>Radius</code></a> enum constant to choose the distance measurement.
 <br>
 This method should not be used from multiple threads; it uses internal static state. You can use the Shadow FOV
 methods instead if you need multi-threading.
 <br>
 Ripple is a significantly slower algorithm than Shadow, typically by more than an order of magnitude.
 Still, unless you are making many FOV calls per frame rendered, it's unlikely to be a severe bottleneck,
 although this is possible. <a href="Radiance.html" title="class in com.github.yellowstonegames.grid"><code>Radiance</code></a>, which typically makes an FOV call once per frame per Radiance,
 should always use Shadow, but if you only calculate FOV for the player, or only when they move, then either
 Shadow or Ripple can be suitable.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - probably calculated with <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a>; 1.0f blocks light, 0.0f allows it</dd>
<dd><code>light</code> - will be overwritten! Should be initialized with the same size as <code>resistanceMap</code></dd>
<dd><code>x</code> - starting x position to look from</dd>
<dd><code>y</code> - starting y position to look from</dd>
<dd><code>radius</code> - the distance to extend from the starting x,y position</dd>
<dd><code>radiusTechnique</code> - how to measure distance; typically <a href="Radius.html#CIRCLE"><code>Radius.CIRCLE</code></a>.</dd>
<dt>Returns:</dt>
<dd><code>light</code>, after writing the FOV map into it; 1.0f is fully lit and 0.0f is unseen</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseRippleFOV(float[][],float[][],int,int,int,float,com.github.yellowstonegames.grid.Radius)">
<h3>reuseRippleFOV</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseRippleFOV</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;rippleLooseness,
 int&nbsp;x,
 int&nbsp;y,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique)</span></div>
<div class="block">Like the <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)"><code>reuseFOV(float[][], float[][], int, int, float, Radius)</code></a> method, but this uses Ripple FOV
 with a configurable tightness/looseness (between 1, tightest, and 6, loosest). Other parameters are similar; you
 can get a resistance map from <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a>, <code>light</code> will be modified and returned
 (it will be overwritten, but its size should be the same as the resistance map), there's a starting x,y position,
 a radius in cells, and a <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid"><code>Radius</code></a> enum constant to choose the distance measurement.
 <br>
 This method should not be used from multiple threads; it uses internal static state. You can use the Shadow FOV
 methods instead if you need multi-threading.
 <br>
 Ripple is a significantly slower algorithm than Shadow, typically by more than an order of magnitude.
 Still, unless you are making many FOV calls per frame rendered, it's unlikely to be a severe bottleneck,
 although this is possible. <a href="Radiance.html" title="class in com.github.yellowstonegames.grid"><code>Radiance</code></a>, which typically makes an FOV call once per frame per Radiance,
 should always use Shadow, but if you only calculate FOV for the player, or only when they move, then either
 Shadow or Ripple can be suitable.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - probably calculated with <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a>; 1.0f blocks light, 0.0f allows it</dd>
<dd><code>light</code> - will be overwritten! Should be initialized with the same size as <code>resistanceMap</code></dd>
<dd><code>rippleLooseness</code> - affects spread; between 1 and 6, inclusive; 1 is tightest, 2 is normal, and 6 is loosest</dd>
<dd><code>x</code> - starting x position to look from</dd>
<dd><code>y</code> - starting y position to look from</dd>
<dd><code>radius</code> - the distance to extend from the starting x,y position</dd>
<dd><code>radiusTechnique</code> - how to measure distance; typically <a href="Radius.html#CIRCLE"><code>Radius.CIRCLE</code></a>.</dd>
<dt>Returns:</dt>
<dd><code>light</code>, after writing the FOV map into it; 1.0f is fully lit and 0.0f is unseen</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseSoundField(float[][],float[][],int,int,float,com.github.yellowstonegames.grid.Radius)">
<h3>reuseSoundField</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseSoundField</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;sound,
 int&nbsp;x,
 int&nbsp;y,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique)</span></div>
<div class="block">Like the <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)"><code>reuseFOV(float[][], float[][], int, int, float, Radius)</code></a> method, but this is meant for sound
 rather than light, and so uses Ripple FOV with maximum looseness, and expects a sound resistance map rather than
 a light one. Other parameters are similar; you can get a sound resistance map from
 <a href="#generateSoundResistances(char%5B%5D%5B%5D)"><code>generateSoundResistances(char[][])</code></a>, <code>sound</code> will be modified and returned (it will be overwritten,
 but its size should be the same as the resistance map), there's a starting x,y position for the sound, a radius
 in cells, and a <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid"><code>Radius</code></a> enum constant to choose the distance measurement.
 <br>
 If you have loud background noise in a map, you can simulate all other sounds being harder to hear by subtracting
 some value from all results in <code>sound</code>. With the default settings in
 <a href="#generateSoundResistances(char%5B%5D%5B%5D)"><code>generateSoundResistances(char[][])</code></a>, thin walls (one cell thick) and doors will allow some sound through,
 while thick walls (two or more cells) will allow none.
 <br>
 This method should not be used from multiple threads; it uses internal static state.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - probably calculated with <a href="#generateSoundResistances(char%5B%5D%5B%5D)"><code>generateSoundResistances(char[][])</code></a>; 1.0f blocks sound, 0.0f allows it</dd>
<dd><code>sound</code> - will be overwritten! Should be initialized with the same size as <code>resistanceMap</code></dd>
<dd><code>x</code> - starting x position to emit sound from</dd>
<dd><code>y</code> - starting y position to emit sound from</dd>
<dd><code>radius</code> - the maximum distance to extend from the starting x,y position</dd>
<dd><code>radiusTechnique</code> - how to measure distance; typically <a href="Radius.html#CIRCLE"><code>Radius.CIRCLE</code></a>.</dd>
<dt>Returns:</dt>
<dd><code>sound</code>, after writing the sound field into it; 1.0f is max volume and 0.0f is inaudible</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseRippleFOV(float[][],float[][],int,int,int,float,com.github.yellowstonegames.grid.Radius,float,float)">
<h3>reuseRippleFOV</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseRippleFOV</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;rippleLooseness,
 int&nbsp;x,
 int&nbsp;y,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;span)</span></div>
<div class="block">Like the <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius,float,float)"><code>reuseFOV(float[][], float[][], int, int, float, Radius, float, float)</code></a> method, but this
 uses Ripple FOV with a configurable tightness/looseness (between 1, tightest, and 6, loosest). Other parameters
 are similar; you can get a resistance map from <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a>, <code>light</code> will be
 modified and returned (it will be overwritten, but its size should be the same as the resistance map), there's 
 starting x,y position, a radius in cells, a <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid"><code>Radius</code></a> enum constant to choose the distance measurement, and
 the angle/span combination to specify a conical section of FOV (span is the total in degrees, centered on angle).
 <br>
 This method should not be used from multiple threads; it uses internal static state. You can use the Shadow FOV
 methods instead if you need multi-threading.
 <br>
 Ripple is a significantly slower algorithm than Shadow, typically by more than an order of magnitude.
 Still, unless you are making many FOV calls per frame rendered, it's unlikely to be a severe bottleneck,
 although this is possible. <a href="Radiance.html" title="class in com.github.yellowstonegames.grid"><code>Radiance</code></a>, which typically makes an FOV call once per frame per Radiance,
 should always use Shadow, but if you only calculate FOV for the player, or only when they move, then either
 Shadow or Ripple can be suitable.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - probably calculated with <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a>; 1.0f blocks light, 0.0f allows it</dd>
<dd><code>light</code> - will be overwritten! Should be initialized with the same size as <code>resistanceMap</code></dd>
<dd><code>rippleLooseness</code> - affects spread; between 1 and 6, inclusive; 1 is tightest, 2 is normal, and 6 is loosest</dd>
<dd><code>x</code> - starting x position to look from</dd>
<dd><code>y</code> - starting y position to look from</dd>
<dd><code>radius</code> - the distance to extend from the starting x,y position</dd>
<dd><code>radiusTechnique</code> - how to measure distance; typically <a href="Radius.html#CIRCLE"><code>Radius.CIRCLE</code></a>.</dd>
<dd><code>angle</code> - the angle to center the conical FOV on</dd>
<dd><code>span</code> - the total span in degrees for the conical FOV to cover</dd>
<dt>Returns:</dt>
<dd><code>light</code>, after writing the FOV map into it; 1.0f is fully lit and 0.0f is unseen</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="bouncingLine(float[][],float[][],int,int,float,float)">
<h3>bouncingLine</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">bouncingLine</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;distance,
 float&nbsp;angle)</span></div>
<div class="block">Reuses the existing light 2D array and fills it with a straight-line bouncing path of light that reflects its way
 through the given resistanceMap from startX, startY until it uses up the given distance. The angle the path
 takes is given in degrees, and the angle used can change as obstacles are hit (reflecting backwards if it hits a
 corner pointing directly into or away from its path). This can be used something like an LOS method, but because
 the path can be traveled back over, an array or Queue becomes somewhat more complex, and the decreasing numbers
 for a straight line that stack may make more sense for how this could be used (especially with visual effects).
 This currently allows the path to pass through single-cell wall-like obstacles without changing direction, e.g.
 it passes through pillars, but will bounce if it hits a bigger wall.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - the grid of cells to calculate on; the kind made by <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a></dd>
<dd><code>light</code> - the grid of cells to assign to; may have existing values, and 0.0f is used to mean "unlit"</dd>
<dd><code>startX</code> - the horizontal component of the starting location</dd>
<dd><code>startY</code> - the vertical component of the starting location</dd>
<dd><code>distance</code> - the distance the light will extend to</dd>
<dd><code>angle</code> - in degrees, the angle to start the path traveling in</dd>
<dt>Returns:</dt>
<dd>the given light parameter, after modifications</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseFOV(float[][],float[][],int,int,float,com.github.yellowstonegames.grid.Radius,float,float,float,float,float,float)">
<h3>reuseFOV</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseFOV</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;forward,
 float&nbsp;sideForward,
 float&nbsp;side,
 float&nbsp;sideBack,
 float&nbsp;back)</span></div>
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates, lighting with the view "pointed at" the given <code>angle</code> in degrees,
 extending to different ranges based on the direction the light is traveling.
 The direction ranges are <code>forward</code>, <code>sideForward</code>, <code>side</code>,
 <code>sideBack</code>, and <code>back</code>; all are multiplied by <code>radius</code>.
 Assigns to, and returns, a light map where the values represent a percentage of fully
 lit. The values in light are cleared before this is run, because prior state can make
 this give incorrect results. You can use <a href="#addFOVsInto(float%5B%5D%5B%5D,float%5B%5D%5B%5D...)"><code>addFOVsInto(float[][], float[][]...)</code></a>
 if you want to mix FOV results, which works as an alternative to using the prior light state.
 <br>
 The starting point for the calculation is considered to be at the center
 of the origin cell. Radius determinations are determined by the provided
 RadiusStrategy. If all direction ranges are the same, this acts like
 <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)"><code>reuseFOV(float[][], float[][], int, int, float, Radius)</code></a>; otherwise
 may produce conical shapes (potentially more than one, or overlapping ones).
 <br>
 This is an alias for <a href="#reuseFOVDeg(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius,float,float,float,float,float,float)"><code>reuseFOVDeg(float[][], float[][], int, int, float, Radius, float, float, float, float, float, float)</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - the grid of cells to calculate on; the kind made by <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a></dd>
<dd><code>light</code> - the grid of cells to assign to; may have existing values, and 0.0f is used to mean "unlit"</dd>
<dd><code>startX</code> - the horizontal component of the starting location</dd>
<dd><code>startY</code> - the vertical component of the starting location</dd>
<dd><code>radius</code> - the distance the light will extend to (roughly); direction ranges will be multiplied by this</dd>
<dd><code>radiusTechnique</code> - provides a means to shape the FOV by changing distance calculation (circle, square, etc.)</dd>
<dd><code>angle</code> - the angle in degrees that will be the center of the FOV cone, 0 points right</dd>
<dd><code>forward</code> - the portion of <code>radius</code> to extend when the light is within 22.5f degrees of angle; will be interpolated with sideForward</dd>
<dd><code>sideForward</code> - the portion of <code>radius</code> to extend when the light is between 22.5f and 67.5f degrees of angle; will be interpolated with forward or side</dd>
<dd><code>side</code> - the portion of <code>radius</code> to extend when the light is between 67.5f and 112.5f degrees of angle; will be interpolated with sideForward or sideBack</dd>
<dd><code>sideBack</code> - the portion of <code>radius</code> to extend when the light is between 112.5f and 157.5f degrees of angle; will be interpolated with side or back</dd>
<dd><code>back</code> - the portion of <code>radius</code> to extend when the light is more than 157.5f degrees away from angle; will be interpolated with sideBack</dd>
<dt>Returns:</dt>
<dd>the computed light grid (the same as <code>light</code>)</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseFOVRad(float[][],float[][],int,int,float,com.github.yellowstonegames.grid.Radius,float,float,float,float,float,float)">
<h3>reuseFOVRad</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseFOVRad</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;forward,
 float&nbsp;sideForward,
 float&nbsp;side,
 float&nbsp;sideBack,
 float&nbsp;back)</span></div>
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates, lighting with the view "pointed at" the given <code>angle</code> in radians,
 extending to different ranges based on the direction the light is traveling.
 The direction ranges are <code>forward</code>, <code>sideForward</code>, <code>side</code>,
 <code>sideBack</code>, and <code>back</code>; all are multiplied by <code>radius</code>.
 Assigns to, and returns, a light map where the values represent a percentage of fully
 lit. The values in light are cleared before this is run, because prior state can make
 this give incorrect results. You can use <a href="#addFOVsInto(float%5B%5D%5B%5D,float%5B%5D%5B%5D...)"><code>addFOVsInto(float[][], float[][]...)</code></a>
 if you want to mix FOV results, which works as an alternative to using the prior light state.
 <br>
 The starting point for the calculation is considered to be at the center
 of the origin cell. Radius determinations are determined by the provided
 RadiusStrategy. If all direction ranges are the same, this acts like
 <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)"><code>reuseFOV(float[][], float[][], int, int, float, Radius)</code></a>; otherwise
 may produce conical shapes (potentially more than one, or overlapping ones).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - the grid of cells to calculate on; the kind made by <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a></dd>
<dd><code>light</code> - the grid of cells to assign to; may have existing values, and 0.0f is used to mean "unlit"</dd>
<dd><code>startX</code> - the horizontal component of the starting location</dd>
<dd><code>startY</code> - the vertical component of the starting location</dd>
<dd><code>radius</code> - the distance the light will extend to (roughly); direction ranges will be multiplied by this</dd>
<dd><code>radiusTechnique</code> - provides a means to shape the FOV by changing distance calculation (circle, square, etc.)</dd>
<dd><code>angle</code> - the angle in radians that will be the center of the FOV cone, 0 points right</dd>
<dd><code>forward</code> - the portion of <code>radius</code> to extend when the light is within PI/8 radians of angle; will be interpolated with sideForward</dd>
<dd><code>sideForward</code> - the portion of <code>radius</code> to extend when the light is between PI/8 and 3*PI/8 radians of angle; will be interpolated with forward or side</dd>
<dd><code>side</code> - the portion of <code>radius</code> to extend when the light is between 3*PI/8 and 5*PI/8 radians of angle; will be interpolated with sideForward or sideBack</dd>
<dd><code>sideBack</code> - the portion of <code>radius</code> to extend when the light is between 5*PI/8 and 7*PI/8 radians of angle; will be interpolated with side or back</dd>
<dd><code>back</code> - the portion of <code>radius</code> to extend when the light is more than 7*PI/8 radians away from angle; will be interpolated with sideBack</dd>
<dt>Returns:</dt>
<dd>the computed light grid (the same as <code>light</code>)</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseFOVDeg(float[][],float[][],int,int,float,com.github.yellowstonegames.grid.Radius,float,float,float,float,float,float)">
<h3>reuseFOVDeg</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseFOVDeg</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;forward,
 float&nbsp;sideForward,
 float&nbsp;side,
 float&nbsp;sideBack,
 float&nbsp;back)</span></div>
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates, lighting with the view "pointed at" the given <code>angle</code> in degrees,
 extending to different ranges based on the direction the light is traveling.
 The direction ranges are <code>forward</code>, <code>sideForward</code>, <code>side</code>,
 <code>sideBack</code>, and <code>back</code>; all are multiplied by <code>radius</code>.
 Assigns to, and returns, a light map where the values represent a percentage of fully
 lit. The values in light are cleared before this is run, because prior state can make
 this give incorrect results. You can use <a href="#addFOVsInto(float%5B%5D%5B%5D,float%5B%5D%5B%5D...)"><code>addFOVsInto(float[][], float[][]...)</code></a>
 if you want to mix FOV results, which works as an alternative to using the prior light state.
 <br>
 The starting point for the calculation is considered to be at the center
 of the origin cell. Radius determinations are determined by the provided
 RadiusStrategy. If all direction ranges are the same, this acts like
 <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)"><code>reuseFOV(float[][], float[][], int, int, float, Radius)</code></a>; otherwise
 may produce conical shapes (potentially more than one, or overlapping ones).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - the grid of cells to calculate on; the kind made by <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a></dd>
<dd><code>light</code> - the grid of cells to assign to; may have existing values, and 0.0f is used to mean "unlit"</dd>
<dd><code>startX</code> - the horizontal component of the starting location</dd>
<dd><code>startY</code> - the vertical component of the starting location</dd>
<dd><code>radius</code> - the distance the light will extend to (roughly); direction ranges will be multiplied by this</dd>
<dd><code>radiusTechnique</code> - provides a means to shape the FOV by changing distance calculation (circle, square, etc.)</dd>
<dd><code>angle</code> - the angle in degrees that will be the center of the FOV cone, 0 points right</dd>
<dd><code>forward</code> - the portion of <code>radius</code> to extend when the light is within 22.5f degrees of angle; will be interpolated with sideForward</dd>
<dd><code>sideForward</code> - the portion of <code>radius</code> to extend when the light is between 22.5f and 67.5f degrees of angle; will be interpolated with forward or side</dd>
<dd><code>side</code> - the portion of <code>radius</code> to extend when the light is between 67.5f and 112.5f degrees of angle; will be interpolated with sideForward or sideBack</dd>
<dd><code>sideBack</code> - the portion of <code>radius</code> to extend when the light is between 112.5f and 157.5f degrees of angle; will be interpolated with side or back</dd>
<dd><code>back</code> - the portion of <code>radius</code> to extend when the light is more than 157.5f degrees away from angle; will be interpolated with sideBack</dd>
<dt>Returns:</dt>
<dd>the computed light grid (the same as <code>light</code>)</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseFOVTurns(float[][],float[][],int,int,float,com.github.yellowstonegames.grid.Radius,float,float,float,float,float,float)">
<h3>reuseFOVTurns</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseFOVTurns</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique,
 float&nbsp;angle,
 float&nbsp;forward,
 float&nbsp;sideForward,
 float&nbsp;side,
 float&nbsp;sideBack,
 float&nbsp;back)</span></div>
<div class="block">Calculates the Field Of View for the provided map from the given x, y
 coordinates, lighting with the view "pointed at" the given <code>angle</code> in turns,
 extending to different ranges based on the direction the light is traveling.
 The direction ranges are <code>forward</code>, <code>sideForward</code>, <code>side</code>,
 <code>sideBack</code>, and <code>back</code>; all are multiplied by <code>radius</code>.
 Assigns to, and returns, a light map where the values represent a percentage of fully
 lit. The values in light are cleared before this is run, because prior state can make
 this give incorrect results. You can use <a href="#addFOVsInto(float%5B%5D%5B%5D,float%5B%5D%5B%5D...)"><code>addFOVsInto(float[][], float[][]...)</code></a>
 if you want to mix FOV results, which works as an alternative to using the prior light state.
 <br>
 The starting point for the calculation is considered to be at the center
 of the origin cell. Radius determinations are determined by the provided
 RadiusStrategy. If all direction ranges are the same, this acts like
 <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)"><code>reuseFOV(float[][], float[][], int, int, float, Radius)</code></a>; otherwise
 may produce conical shapes (potentially more than one, or overlapping ones).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - the grid of cells to calculate on; the kind made by <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a></dd>
<dd><code>light</code> - the grid of cells to assign to; may have existing values, and 0.0f is used to mean "unlit"</dd>
<dd><code>startX</code> - the horizontal component of the starting location</dd>
<dd><code>startY</code> - the vertical component of the starting location</dd>
<dd><code>radius</code> - the distance the light will extend to (roughly); direction ranges will be multiplied by this</dd>
<dd><code>radiusTechnique</code> - provides a means to shape the FOV by changing distance calculation (circle, square, etc.)</dd>
<dd><code>angle</code> - the angle in turns that will be the center of the FOV cone, 0 points right</dd>
<dd><code>forward</code> - the portion of <code>radius</code> to extend when the light is within 1/16f turns of angle; will be interpolated with sideForward</dd>
<dd><code>sideForward</code> - the portion of <code>radius</code> to extend when the light is between 1/16f and 3/16f turns of angle; will be interpolated with forward or side</dd>
<dd><code>side</code> - the portion of <code>radius</code> to extend when the light is between 3/16f and 5/16f turns of angle; will be interpolated with sideForward or sideBack</dd>
<dd><code>sideBack</code> - the portion of <code>radius</code> to extend when the light is between 5/16f and 7/16f turns of angle; will be interpolated with side or back</dd>
<dd><code>back</code> - the portion of <code>radius</code> to extend when the light is more than 7/16f turns away from angle; will be interpolated with sideBack</dd>
<dt>Returns:</dt>
<dd>the computed light grid (the same as <code>light</code>)</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="reuseFOVOrtho(float[][],float[][],int,int,float,com.github.yellowstonegames.grid.Radius)">
<h3>reuseFOVOrtho</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="annotations">@Beta
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">reuseFOVOrtho</span><wbr><span class="parameters">(float[][]&nbsp;resistanceMap,
 float[][]&nbsp;light,
 int&nbsp;startX,
 int&nbsp;startY,
 float&nbsp;radius,
 <a href="Radius.html" title="enum class in com.github.yellowstonegames.grid">Radius</a>&nbsp;radiusTechnique)</span></div>
<div class="block">Calculates the symmetrical Field Of View for the provided resistanceMap from the given x, y viewer
 coordinates. Assigns to, and returns, a light map where the values represent a percentage of fully
 lit. If any cell in the returned light map is greater than 0, then both the viewer can see that cell,
 and anyone in that cell can see the viewer (if they have sufficient viewing range). Always uses Shadow
 FOV, and can reuse the state the user gives it via the <code>light</code> parameter. The values in light
 are always cleared before this is run, because prior state can make this give incorrect results. This
 evaluates if the viewer and target cell can mutually see each other using <a href="OrthoLine.html" title="class in com.github.yellowstonegames.grid"><code>OrthoLine</code></a>.
 <br>
 The starting point for the calculation is considered to be at the center
 of the origin cell. Radius determinations are determined by the provided
 RadiusStrategy.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>resistanceMap</code> - the grid of cells to calculate on; the kind made by <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a></dd>
<dd><code>light</code> - the grid of cells to assign to; may have existing values, and 0.0f is used to mean "unlit"</dd>
<dd><code>startX</code> - the horizontal component of the starting location</dd>
<dd><code>startY</code> - the vertical component of the starting location</dd>
<dd><code>radius</code> - the distance the light will extend to</dd>
<dd><code>radiusTechnique</code> - provides a means to calculate the radius as desired</dd>
<dt>Returns:</dt>
<dd>the computed light grid, which is the same 2D array as the value assigned to <code>light</code></dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="addFOVsInto(float[][],float[][])">
<h3>addFOVsInto</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">addFOVsInto</span><wbr><span class="parameters">(float[][]&nbsp;basis,
 float[][]&nbsp;addend)</span></div>
<div class="block">Adds an FOV grid to another in the simplest way possible; does not check line-of-sight between FOV grids.
 Clamps the highest value for any single position at 1.0f. Modifies the basis parameter in-place and makes no
 allocations; this is different from <a href="#addFOVs(float%5B%5D%5B%5D...)"><code>addFOVs(float[][][])</code></a>, which creates a new 2D array.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>basis</code> - a 2D float array, which can be empty or returned by calculateFOV() or reuseFOV(); modified!</dd>
<dd><code>addend</code> - another 2D float array that will be added into basis; this one will not be modified</dd>
<dt>Returns:</dt>
<dd>the sum of the 2D float arrays passed, using the dimensions of basis if they don't match</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="addFOVs(float[][]...)">
<h3>addFOVs</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">addFOVs</span><wbr><span class="parameters">(float[][]...&nbsp;grids)</span></div>
<div class="block">Adds multiple FOV grids together in the simplest way possible; does not check line-of-sight between FOV grids.
 Clamps the highest value for any single position at 1.0f. Allocates a new 2D float array and returns it.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>grids</code> - an array or vararg of 2D float arrays, each usually returned by calculateFOV()</dd>
<dt>Returns:</dt>
<dd>the sum of all the 2D float arrays passed, using the dimensions of the first if they don't all match</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="addFOVsInto(float[][],float[][]...)">
<h3>addFOVsInto</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">addFOVsInto</span><wbr><span class="parameters">(float[][]&nbsp;basis,
 float[][]...&nbsp;grids)</span></div>
<div class="block">Adds multiple FOV grids to basis cell-by-cell, modifying basis; does not check line-of-sight between FOV grids.
 Clamps the highest value for any single position at 1.0f. Returns basis without allocating new objects.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>basis</code> - a 2D float array that will be modified by adding values in grids to it and clamping to 1.0f or less</dd>
<dd><code>grids</code> - an array or vararg of 2D float arrays, each usually returned by calculateFOV()</dd>
<dt>Returns:</dt>
<dd>basis, with all elements in all grids added to the corresponding cells and clamped</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="addFOVs(java.lang.Iterable)">
<h3>addFOVs</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">addFOVs</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Iterable.html" title="class or interface in java.lang" class="external-link">Iterable</a>&lt;float[][]&gt;&nbsp;grids)</span></div>
<div class="block">Adds multiple FOV grids together in the simplest way possible; does not check line-of-sight between FOV grids.
 Clamps the highest value for any single position at 1.0f. Allocates a new 2D float array and returns it.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>grids</code> - an Iterable of 2D float arrays (most collections implement Iterable),
             each usually returned by calculateFOV()</dd>
<dt>Returns:</dt>
<dd>the sum of all the 2D float arrays passed, using the dimensions of the first if they don't all match</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="mixVisibleFOVs(float[][],float[][]...)">
<h3>mixVisibleFOVs</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">mixVisibleFOVs</span><wbr><span class="parameters">(float[][]&nbsp;losGrid,
 float[][]...&nbsp;grids)</span></div>
<div class="block">Adds together multiple FOV grids, but only adds to a position if it is visible in the given LOS grid. Useful if
 you want distant lighting to be visible only if the player has line-of-sight to a lit cell. Typically the LOS grid
 is calculated by <a href="#reuseLOS(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int)"><code>reuseLOS(float[][], float[][], int, int)</code></a>, using the same resistance grid used to
 calculate the FOV grids. Clamps the highest value for any single position at 1.0f.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>losGrid</code> - an LOS grid such as one generated by <a href="#reuseLOS(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int)"><code>reuseLOS(float[][], float[][], int, int)</code></a></dd>
<dd><code>grids</code> - an array or vararg of 2D float arrays, each usually returned by calculateFOV()</dd>
<dt>Returns:</dt>
<dd>the sum of all the 2D float arrays in grids where a cell was visible in losGrid</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="mixVisibleFOVsInto(float[][],float[][],float[][]...)">
<h3>mixVisibleFOVsInto</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">mixVisibleFOVsInto</span><wbr><span class="parameters">(float[][]&nbsp;losGrid,
 float[][]&nbsp;basis,
 float[][]...&nbsp;grids)</span></div>
<div class="block">Adds together multiple FOV grids, but only adds to a position if it is visible in the given LOS grid. Useful if
 you want distant lighting to be visible only if the player has line-of-sight to a lit cell. Typically, the LOS
 grid is calculated by <a href="#reuseLOS(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int)"><code>reuseLOS(float[][], float[][], int, int)</code></a>, using the same resistance grid used to
 calculate the FOV grids. Clamps the highest value for any single position at 1.0f.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>losGrid</code> - an LOS grid such as one generated by <a href="#reuseLOS(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int)"><code>reuseLOS(float[][], float[][], int, int)</code></a></dd>
<dd><code>basis</code> - an existing 2D float array that should have matching width and height to losGrid; will be modified</dd>
<dd><code>grids</code> - an array or vararg of 2D float arrays, each usually returned by calculateFOV()</dd>
<dt>Returns:</dt>
<dd>the sum of all the 2D float arrays in grids where a cell was visible in losGrid</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="mixVisibleFOVs(float[][],java.lang.Iterable)">
<h3>mixVisibleFOVs</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">mixVisibleFOVs</span><wbr><span class="parameters">(float[][]&nbsp;losGrid,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Iterable.html" title="class or interface in java.lang" class="external-link">Iterable</a>&lt;float[][]&gt;&nbsp;grids)</span></div>
<div class="block">Adds together multiple FOV grids, but only adds to a position if it is visible in the given LOS grid. Useful if
 you want distant lighting to be visible only if the player has line-of-sight to a lit cell. Typically the LOS grid
 is calculated by <a href="#reuseLOS(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int)"><code>reuseLOS(float[][], float[][], int, int)</code></a>, using the same resistance grid used to
 calculate the FOV grids. Clamps the highest value for any single position at 1.0f.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>losGrid</code> - an LOS grid such as one generated by <a href="#reuseLOS(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int)"><code>reuseLOS(float[][], float[][], int, int)</code></a></dd>
<dd><code>grids</code> - an Iterable of 2D float arrays, each usually returned by calculateFOV()</dd>
<dt>Returns:</dt>
<dd>the sum of all the 2D float arrays in grids where a cell was visible in losGrid</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="resistance(char)">
<h3>resistance</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">resistance</span><wbr><span class="parameters">(char&nbsp;cell)</span></div>
<div class="block">Given a single char, returns what <a href="#generateResistances(char%5B%5D%5B%5D)"><code>generateResistances(char[][])</code></a> or
 <a href="#fillResistancesInto(char%5B%5D%5B%5D,float%5B%5D%5B%5D)"><code>fillResistancesInto(char[][], float[][])</code></a> would consider as its light resistance value.
 This means that for a wall char (<code>'#'</code> or a box drawing character) or an impossible-to-see character
 (<code>' '</code>), this returns a resistance of 1f, for an open door (<code>'/'</code>) this returns
 0.15f, for a closed door (<code>'+'</code>) this returns 0.95f, and for any other char, this returns 0f.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>cell</code> - a single char that uses the place-map conventions the rest of this class uses</dd>
<dt>Returns:</dt>
<dd>the light resistance value for a cell represented by <code>cell</code></dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="simpleResistance(char)">
<h3>simpleResistance</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">simpleResistance</span><wbr><span class="parameters">(char&nbsp;cell)</span></div>
<div class="block">Given a single char, returns what <a href="#generateSimpleResistances(char%5B%5D%5B%5D)"><code>generateSimpleResistances(char[][])</code></a> or
 <a href="#fillSimpleResistancesInto(char%5B%5D%5B%5D,float%5B%5D%5B%5D)"><code>fillSimpleResistancesInto(char[][], float[][])</code></a> would consider as its light resistance value.
 This means that for a wall char (<code>'#'</code> or a box drawing character), a closed door (<code>'+'</code>), or an
 impossible-to-see character (<code>' '</code>), this returns a resistance of 1f, and for any
 other char, this returns 0f.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>cell</code> - a single char that uses the place-map conventions the rest of this class uses</dd>
<dt>Returns:</dt>
<dd>the light resistance value for a cell represented by <code>cell</code></dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="generateResistances(char[][])">
<h3>generateResistances</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">generateResistances</span><wbr><span class="parameters">(char[][]&nbsp;map)</span></div>
<div class="block">Given a char[][] for the local area, produces a float[][] that can be used with most of the methods in FOV, like
 <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float)"><code>reuseFOV(float[][], float[][], int, int, float)</code></a>. It expects any doors to be represented by '+' if
 closed or '/' if open, any walls to be '#' or box drawing characters, and it doesn't care what other chars are
 used (only doors, including open ones, and walls obscure light and thus have a resistance by default). Open doors
 slightly obscure light, closed doors obscure almost all light coming from the other side, walls block all light,
 and anything else does not obscure light.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>map</code> - a dungeon, width by height, with any closed doors as '+' and open doors as '/'</dd>
<dt>Returns:</dt>
<dd>a resistance map suitable for use with the FOV class, with clear cells assigned 0.0f and blocked ones 1.0f</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list-long">
<li><a href="#generateSimpleResistances(char%5B%5D%5B%5D)"><code>generateSimpleResistances(char[][])</code></a></li>
</ul>
</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="fillResistancesInto(char[][],float[][])">
<h3>fillResistancesInto</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">fillResistancesInto</span><wbr><span class="parameters">(char[][]&nbsp;grid,
 float[][]&nbsp;into)</span></div>
<div class="block">Given a char[][] for the local area and a float[][] with the same dimensions as the chars, fills the float[][] so
 it can be used with most of the methods in FOV, like <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float)"><code>reuseFOV(float[][], float[][], int, int, float)</code></a>. It
 expects any doors to be represented by '+' if closed or '/' if open, any walls to be '#' or box drawing
 characters, and it doesn't care what other chars are used (only doors, including open ones, and walls obscure
 light and thus have a resistance by default). Open doors slightly obscure light, closed doors obscure almost all
 light coming from the other side, walls block all light, and anything else does not obscure light.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>grid</code> - a 2D char array, width by height, with any closed doors as '+' and open doors as '/'</dd>
<dd><code>into</code> - a 2D float array that should have the same dimensions as <code>grid</code>; will be modified completely</dd>
<dt>Returns:</dt>
<dd><code>into</code> modified so it acts as a resistance grid, with clear cells assigned 0.0f and blocked ones 1.0f</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="generateResistances3x3(char[][])">
<h3>generateResistances3x3</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">generateResistances3x3</span><wbr><span class="parameters">(char[][]&nbsp;grid)</span></div>
<div class="block">Given a char[][] for the local area that should use box drawing characters, produces a float[][] with triple
 width and triple height that can be used with FOV methods like
 <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float)"><code>reuseFOV(float[][], float[][], int, int, float)</code></a> in classes that use subcell lighting. Importantly, this
 only considers a "thin line" of wall to be blocking (matching the box drawing character), instead of the whole
 3x3 area. This expects any doors to be represented by '+' if closed or '/' if open, any normal walls to be box
 drawing characters, any cells that block all subcells to be '#', and it doesn't care what other chars are used
 (only doors, including open ones, and walls obscure light and thus have a resistance normally).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>grid</code> - a place grid as a 2D char array, width by height, with any closed doors as '+' and open doors as '/'</dd>
<dt>Returns:</dt>
<dd>a resistance grid suitable for use with the FOV class and subcell lighting, with triple width/height</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="generateSimpleResistances(char[][])">
<h3>generateSimpleResistances</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">generateSimpleResistances</span><wbr><span class="parameters">(char[][]&nbsp;grid)</span></div>
<div class="block">Given a char[][] for the local area, produces a float[][] that can be used with any FOV methods that expect a
 resistance grid (like <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float)"><code>reuseFOV(float[][], float[][], int, int, float)</code></a>), but does not treat
 any cells as partly transparent, only fully-blocking or fully-permitting light. This is mainly useful if you
 expect the FOV radius to be very high or (effectively) infinite, since anything less than complete blockage would
 be passed through by infinite-radius FOV. This expects any doors to be represented by '+' if closed or '/' if
 open, and any walls to be '#' or box drawing characters. This will assign 1.0f resistance to walls and closed
 doors or 0.0f for any other cell.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>grid</code> - a place grid, width by height, with any closed doors as '+' and open doors as '/'</dd>
<dt>Returns:</dt>
<dd>a resistance grid suitable for use with the FOV class, but with no partially transparent cells</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="fillSimpleResistancesInto(char[][],float[][])">
<h3>fillSimpleResistancesInto</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">fillSimpleResistancesInto</span><wbr><span class="parameters">(char[][]&nbsp;grid,
 float[][]&nbsp;into)</span></div>
<div class="block">Given a char[][] for the local area and a float[][] with the same dimensions as the chars, fills the float[][] so it can
 be used with most of the methods in FOV, like <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float)"><code>reuseFOV(float[][], float[][], int, int, float)</code></a>, but does
 not treat any cells as partly transparent, only fully-blocking or fully-permitting light. This is mainly useful
 if you expect the FOV radius to be very high or (effectively) infinite, since anything less than complete
 blockage would be passed through by infinite-radius FOV. This expects any doors to be represented by '+' if
 closed or '/' if open, and any walls to be '#' or box drawing characters. This will assign 1.0f resistance to
 walls and closed doors or 0.0f for any other cell.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>grid</code> - a 2D char array, width by height, with any closed doors as '+' and open doors as '/'</dd>
<dd><code>into</code> - a 2D float array that should have the same dimensions as <code>grid</code>; will be modified completely</dd>
<dt>Returns:</dt>
<dd><code>into</code> modified so it acts as a resistance grid, with clear cells assigned 0.0f and blocked ones 1.0f</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="generateSimpleResistances3x3(char[][])">
<h3>generateSimpleResistances3x3</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">generateSimpleResistances3x3</span><wbr><span class="parameters">(char[][]&nbsp;grid)</span></div>
<div class="block">Given a char[][] for the local area that should use box drawing characters, produces a float[][] with triple
 width and triple height that can be used with FOV's methods that expect a resistance grid (like
 <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float)"><code>reuseFOV(float[][], float[][], int, int, float)</code></a>) in classes that use subcell lighting. This expects
 any doors to be represented by '+' if closed or '/' if open, any walls to be box drawing characters, and any
 cells that block all subcells within their area to be '#'. This will assign 1.0f resistance to walls and closed
 doors where a line of the box drawing char would block light, or 0.0f for any other subcell.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>grid</code> - a dungeon, width by height, with any closed doors as '+' and open doors as '/'</dd>
<dt>Returns:</dt>
<dd>a resistance grid suitable for use with the FOV class and subcell lighting, with triple width/height</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="generateSoundResistances(char[][])">
<h3>generateSoundResistances</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float[][]</span>&nbsp;<span class="element-name">generateSoundResistances</span><wbr><span class="parameters">(char[][]&nbsp;grid)</span></div>
<div class="block">Given a char[][] for the local area, produces a float[][] that can be used with the sound-related methods here,
 allowing sound to pass through thin-enough walls and doors. It expects any doors to be represented by '+' if
 closed or '/' if open, any walls to be '#' or box drawing characters, anything that can't possibly let sound
 through to be ' ' or Unicode u0001, and lets everything else permit sound to pass freely. Open doors slightly
 obscure sound (by 5%), closed doors obscure 30% of sound coming from the other side, walls block 55% of the
 sound (making walls that are 2-cells-thick block all sound, but 1-cell-thick walls won't), the ' ' and Unicode 1
 cells block all sound, and everything else lets sound through.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>grid</code> - a 2D char array, width by height, with any closed doors as '+' and open doors as '/'</dd>
<dt>Returns:</dt>
<dd>a resistance grid meant for sound resistance rather than light, with clear cells assigned 0.0f and fully-blocked ones 1.0f</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="cellsByDescendingValue(float[][])">
<h3>cellsByDescendingValue</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="CoordFloatOrderedMap.html" title="class in com.github.yellowstonegames.grid">CoordFloatOrderedMap</a></span>&nbsp;<span class="element-name">cellsByDescendingValue</span><wbr><span class="parameters">(float[][]&nbsp;fovGrid)</span></div>
<div class="block">Given a typical FOV grid produced by <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int)"><code>reuseFOV(float[][], float[][], int, int)</code></a>,
 <a href="#reuseRippleFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)"><code>reuseRippleFOV(float[][], float[][], int, int, float, Radius)</code></a>, or a similar method, this gets a
 <a href="CoordFloatOrderedMap.html" title="class in com.github.yellowstonegames.grid"><code>CoordFloatOrderedMap</code></a> containing only the visible Coord cells as keys, associated with their visibility
 levels, and ordered so the most-visible cell (typically where the viewer is) is first in the iteration order.
 Lower visibility values will go later and later in the iteration order. This method allocates a new
 CoordFloatOrderedMap; if you want to reuse an existing one, use
 <a href="#fillCellsByDescendingValue(float%5B%5D%5B%5D,com.github.yellowstonegames.grid.CoordFloatOrderedMap)"><code>fillCellsByDescendingValue(float[][], CoordFloatOrderedMap)</code></a> instead.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>fovGrid</code> - a rectangular 2D float array ideally containing values greater than 0 and less than or equal to 1</dd>
<dt>Returns:</dt>
<dd>a CoordFloatOrderedMap containing the non-zero values in fovGrid, ordered from the highest value to lowest</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="fillCellsByDescendingValue(float[][],com.github.yellowstonegames.grid.CoordFloatOrderedMap)">
<h3>fillCellsByDescendingValue</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="CoordFloatOrderedMap.html" title="class in com.github.yellowstonegames.grid">CoordFloatOrderedMap</a></span>&nbsp;<span class="element-name">fillCellsByDescendingValue</span><wbr><span class="parameters">(float[][]&nbsp;fovGrid,
 <a href="CoordFloatOrderedMap.html" title="class in com.github.yellowstonegames.grid">CoordFloatOrderedMap</a>&nbsp;modifying)</span></div>
<div class="block">Given a typical FOV map produced by <a href="#reuseFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int)"><code>reuseFOV(float[][], float[][], int, int)</code></a>,
 <a href="#reuseRippleFOV(float%5B%5D%5B%5D,float%5B%5D%5B%5D,int,int,float,com.github.yellowstonegames.grid.Radius)"><code>reuseRippleFOV(float[][], float[][], int, int, float, Radius)</code></a>, or a similar method and a
 <a href="CoordFloatOrderedMap.html" title="class in com.github.yellowstonegames.grid"><code>CoordFloatOrderedMap</code></a> <code>modifying</code> to clear and reuse in-place, this fills <code>modifying</code>
 with only the visible Coord cells as keys, associated with their visibility
 levels, and ordered so the most-visible cell (typically where the viewer is) is first in the iteration order.
 Lower visibility values will go later and later in the iteration order. This is meant to reuse a
 CoordFloatOrderedMap to avoid allocations, but if you don't have one, you could easily call
 <a href="#cellsByDescendingValue(float%5B%5D%5B%5D)"><code>cellsByDescendingValue(float[][])</code></a> to get a starting point.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>fovGrid</code> - a rectangular 2D float array ideally containing values greater than 0 and less than or equal to 1</dd>
<dd><code>modifying</code> - a <a href="CoordFloatOrderedMap.html" title="class in com.github.yellowstonegames.grid"><code>CoordFloatOrderedMap</code></a> that will have its contents cleared and then refilled by this</dd>
<dt>Returns:</dt>
<dd><code>modifying</code> now containing the non-zero values in fovGrid, ordered from the highest value to lowest</dd>
</dl>
</div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</body>
</html>
