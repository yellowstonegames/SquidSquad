<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>LongPointHash (squidgrid 0.0.1-SNAPSHOT API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: com.github.yellowstonegames.grid, class: LongPointHash">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":10,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">com.github.yellowstonegames.grid</a></div>
<h1 title="Class LongPointHash" class="title">Class LongPointHash</h1>
</div>
<div class="inheritance" title="Inheritance Tree">java.lang.Object
<div class="inheritance"><a href="IPointHash.LongImpl.html" title="class in com.github.yellowstonegames.grid">com.github.yellowstonegames.grid.IPointHash.LongImpl</a>
<div class="inheritance">com.github.yellowstonegames.grid.LongPointHash</div>
</div>
</div>
<section class="description">
<dl class="notes">
<dt>All Implemented Interfaces:</dt>
<dd><code><a href="IPointHash.html" title="interface in com.github.yellowstonegames.grid">IPointHash</a></code></dd>
</dl>
<hr>
<pre>public final class <span class="type-name-label">LongPointHash</span>
extends <a href="IPointHash.LongImpl.html" title="class in com.github.yellowstonegames.grid">IPointHash.LongImpl</a></pre>
<div class="block">A group of similar methods for getting hashes of points based on long coordinates in 2, 3, 4, or 6 dimensions and
 a long for state. This implementation has high enough quality to be useful as a source of random numbers based on
 positions, as long as the number of points hashed isn't extreme (correlations may be detectable after some millions
 or billions of points). You should consider <a href="IntPointHash.html" title="class in com.github.yellowstonegames.grid"><code>IntPointHash</code></a> if your input and output types are usually int,
 since it's even faster, but if your seed is usually a long then this is appropriate.
 <br>
 This implements <a href="IPointHash.html" title="interface in com.github.yellowstonegames.grid"><code>IPointHash</code></a> and has a long it uses internally for state, exposed by <a href="#getState()"><code>getState()</code></a>.</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested.class.summary">
<h2>Nested Class Summary</h2>
<div class="inherited-list">
<h2 id="nested.classes.inherited.from.class.com.github.yellowstonegames.grid.IPointHash">Nested classes/interfaces inherited from interface&nbsp;com.github.yellowstonegames.grid.<a href="IPointHash.html" title="interface in com.github.yellowstonegames.grid">IPointHash</a></h2>
<code><a href="IPointHash.IntImpl.html" title="class in com.github.yellowstonegames.grid">IPointHash.IntImpl</a>, <a href="IPointHash.LongImpl.html" title="class in com.github.yellowstonegames.grid">IPointHash.LongImpl</a></code></div>
</section>
</li>
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field.summary">
<h2>Field Summary</h2>
<div class="inherited-list">
<h3 id="fields.inherited.from.class.com.github.yellowstonegames.grid.IPointHash.LongImpl">Fields inherited from class&nbsp;com.github.yellowstonegames.grid.<a href="IPointHash.LongImpl.html" title="class in com.github.yellowstonegames.grid">IPointHash.LongImpl</a></h3>
<code><a href="IPointHash.LongImpl.html#state">state</a></code></div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor.summary">
<h2>Constructor Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Constructors</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Constructor</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<th class="col-constructor-name" scope="row"><code><span class="member-name-link"><a href="#%3Cinit%3E()">LongPointHash</a></span>()</code></th>
<td class="col-last">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t1" class="table-tab" onclick="show(1);">Static Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="table-tab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="table-tab" onclick="show(8);">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code>long</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getState()">getState</a></span>()</code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hash256(long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets an 8-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hash256(long,long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets an 8-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hash256(long,long,long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets an 8-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hash256(long,long,long,long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets an 8-bit point hash of a 5D point (x, y, z, w, and u are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hash256(long,long,long,long,long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets an 8-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hash256_alt(long,long,long,long,long)">hash256_alt</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;seed)</code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hash32(long,long,long)">hash32</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets a 5-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hash32(long,long,long,long)">hash32</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets a 5-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hash32(long,long,long,long,long)">hash32</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets a 5-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="alt-color" id="i10">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hash32(long,long,long,long,long,long,long)">hash32</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets a 5-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="row-color" id="i11">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hash64(long,long,long)">hash64</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets a 6-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="alt-color" id="i12">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hash64(long,long,long,long)">hash64</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets a 6-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="row-color" id="i13">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hash64(long,long,long,long,long)">hash64</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets a 6-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="alt-color" id="i14">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hash64(long,long,long,long,long,long,long)">hash64</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets a 6-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="row-color" id="i15">
<td class="col-first"><code>static long</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hashAll(long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets a 64-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="alt-color" id="i16">
<td class="col-first"><code>static long</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hashAll(long,long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets a 64-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="row-color" id="i17">
<td class="col-first"><code>static long</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hashAll(long,long,long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets a 64-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="alt-color" id="i18">
<td class="col-first"><code>static long</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hashAll(long,long,long,long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets a 64-bit point hash of a 5D point (x, y, z, w, and u are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="row-color" id="i19">
<td class="col-first"><code>static long</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hashAll(long,long,long,long,long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</code></th>
<td class="col-last">
<div class="block">Gets a 64-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="alt-color" id="i20">
<td class="col-first"><code>int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hashWithState(int,int,int)">hashWithState</a></span>&#8203;(int&nbsp;x,
int&nbsp;y,
int&nbsp;state)</code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="row-color" id="i21">
<td class="col-first"><code>int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hashWithState(int,int,int,int)">hashWithState</a></span>&#8203;(int&nbsp;x,
int&nbsp;y,
int&nbsp;z,
int&nbsp;state)</code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="alt-color" id="i22">
<td class="col-first"><code>int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hashWithState(int,int,int,int,int)">hashWithState</a></span>&#8203;(int&nbsp;x,
int&nbsp;y,
int&nbsp;z,
int&nbsp;w,
int&nbsp;state)</code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="row-color" id="i23">
<td class="col-first"><code>int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hashWithState(int,int,int,int,int,int)">hashWithState</a></span>&#8203;(int&nbsp;x,
int&nbsp;y,
int&nbsp;z,
int&nbsp;w,
int&nbsp;u,
int&nbsp;state)</code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="alt-color" id="i24">
<td class="col-first"><code>int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hashWithState(int,int,int,int,int,int,int)">hashWithState</a></span>&#8203;(int&nbsp;x,
int&nbsp;y,
int&nbsp;z,
int&nbsp;w,
int&nbsp;u,
int&nbsp;v,
int&nbsp;state)</code></th>
<td class="col-last">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.com.github.yellowstonegames.grid.IPointHash.LongImpl">Methods inherited from class&nbsp;com.github.yellowstonegames.grid.<a href="IPointHash.LongImpl.html" title="class in com.github.yellowstonegames.grid">IPointHash.LongImpl</a></h3>
<code><a href="IPointHash.LongImpl.html#hash(int,int)">hash</a>, <a href="IPointHash.LongImpl.html#hash(int,int,int)">hash</a>, <a href="IPointHash.LongImpl.html#hash(int,int,int,int)">hash</a>, <a href="IPointHash.LongImpl.html#hash(int,int,int,int,int)">hash</a>, <a href="IPointHash.LongImpl.html#hash(int,int,int,int,int,int)">hash</a>, <a href="IPointHash.LongImpl.html#setState(int)">setState</a>, <a href="IPointHash.LongImpl.html#setState(long)">setState</a></code></div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.java.lang.Object">Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor.detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>LongPointHash</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="member-name">LongPointHash</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="hashWithState(int,int,int)">
<h3>hashWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hashWithState</span>&#8203;(<span class="parameters">int&nbsp;x,
int&nbsp;y,
int&nbsp;state)</span></div>
</section>
</li>
<li>
<section class="detail" id="hashWithState(int,int,int,int)">
<h3>hashWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hashWithState</span>&#8203;(<span class="parameters">int&nbsp;x,
int&nbsp;y,
int&nbsp;z,
int&nbsp;state)</span></div>
</section>
</li>
<li>
<section class="detail" id="hashWithState(int,int,int,int,int)">
<h3>hashWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hashWithState</span>&#8203;(<span class="parameters">int&nbsp;x,
int&nbsp;y,
int&nbsp;z,
int&nbsp;w,
int&nbsp;state)</span></div>
</section>
</li>
<li>
<section class="detail" id="hashWithState(int,int,int,int,int,int)">
<h3>hashWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hashWithState</span>&#8203;(<span class="parameters">int&nbsp;x,
int&nbsp;y,
int&nbsp;z,
int&nbsp;w,
int&nbsp;u,
int&nbsp;state)</span></div>
</section>
</li>
<li>
<section class="detail" id="hashWithState(int,int,int,int,int,int,int)">
<h3>hashWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hashWithState</span>&#8203;(<span class="parameters">int&nbsp;x,
int&nbsp;y,
int&nbsp;z,
int&nbsp;w,
int&nbsp;u,
int&nbsp;v,
int&nbsp;state)</span></div>
</section>
</li>
<li>
<section class="detail" id="getState()">
<h3>getState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="member-name">getState</span>()</div>
</section>
</li>
<li>
<section class="detail" id="hashAll(long,long,long)">
<h3>hashAll</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="member-name">hashAll</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt>Returns:</dt>
<dd>64-bit hash of the x,y point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hashAll(long,long,long,long)">
<h3>hashAll</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="member-name">hashAll</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt>Returns:</dt>
<dd>64-bit hash of the x,y,z point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hashAll(long,long,long,long,long)">
<h3>hashAll</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="member-name">hashAll</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>64-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hashAll(long,long,long,long,long,long)">
<h3>hashAll</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="member-name">hashAll</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 5D point (x, y, z, w, and u are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>64-bit hash of the x,y,z,w,u point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hashAll(long,long,long,long,long,long,long)">
<h3>hashAll</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="member-name">hashAll</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>64-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash256(long,long,long)">
<h3>hash256</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hash256</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt>Returns:</dt>
<dd>8-bit hash of the x,y point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash256(long,long,long,long)">
<h3>hash256</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hash256</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt>Returns:</dt>
<dd>8-bit hash of the x,y,z point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash256(long,long,long,long,long)">
<h3>hash256</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hash256</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>8-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash256(long,long,long,long,long,long)">
<h3>hash256</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hash256</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 5D point (x, y, z, w, and u are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>8-bit hash of the x,y,z,w,u point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash256(long,long,long,long,long,long,long)">
<h3>hash256</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hash256</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>8-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash32(long,long,long)">
<h3>hash32</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hash32</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</span></div>
<div class="block">Gets a 5-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt>Returns:</dt>
<dd>5-bit hash of the x,y point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash32(long,long,long,long)">
<h3>hash32</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hash32</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</span></div>
<div class="block">Gets a 5-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt>Returns:</dt>
<dd>5-bit hash of the x,y,z point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash32(long,long,long,long,long)">
<h3>hash32</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hash32</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</span></div>
<div class="block">Gets a 5-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>5-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash32(long,long,long,long,long,long,long)">
<h3>hash32</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hash32</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</span></div>
<div class="block">Gets a 5-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>5-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash64(long,long,long)">
<h3>hash64</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hash64</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</span></div>
<div class="block">Gets a 6-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt>Returns:</dt>
<dd>6-bit hash of the x,y point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash64(long,long,long,long)">
<h3>hash64</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hash64</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</span></div>
<div class="block">Gets a 6-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt>Returns:</dt>
<dd>6-bit hash of the x,y,z point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash64(long,long,long,long,long)">
<h3>hash64</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hash64</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</span></div>
<div class="block">Gets a 6-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>6-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash64(long,long,long,long,long,long,long)">
<h3>hash64</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hash64</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</span></div>
<div class="block">Gets a 6-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt>Returns:</dt>
<dd>6-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hash256_alt(long,long,long,long,long)">
<h3>hash256_alt</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">hash256_alt</span>&#8203;(<span class="parameters">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;seed)</span></div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
</footer>
</div>
</div>
</body>
</html>
