<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>TrigTools (squidcore 0.0.1-SNAPSHOT API)</title>
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="TrigTools (squidcore 0.0.1-SNAPSHOT API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../com/github/yellowstonegames/core/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../com/github/yellowstonegames/core/LZSEncoding.html" title="class in com.github.yellowstonegames.core"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li>Next&nbsp;Class</li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/github/yellowstonegames/core/TrigTools.html" target="_top">Frames</a></li>
<li><a href="TrigTools.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">com.github.yellowstonegames.core</div>
<h2 title="Class TrigTools" class="title">Class TrigTools</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>com.github.yellowstonegames.core.TrigTools</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public final class <span class="typeNameLabel">TrigTools</span>
extends java.lang.Object</pre>
<div class="block">Various fast trigonometric approximations that don't use a lookup table. Some of these are uncommon and useful, like
 <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#sin_-float-"><code>sin_(float)</code></a>, which takes an argument in turns instead of radians (1 turn equals 2PI radians).</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#TrigTools--">TrigTools</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#acos_-double-">acos_</a></span>(double&nbsp;n)</code>
<div class="block">Inverse cosine function (arccos) but with output measured in turns instead of radians.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#acos_-float-">acos_</a></span>(float&nbsp;n)</code>
<div class="block">Inverse cosine function (arccos) but with output measured in turns instead of radians.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#acos-double-">acos</a></span>(double&nbsp;n)</code>
<div class="block">Arc cosine approximation with very low error, based on a simplified version of <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2-double-double-"><code>atan2(double, double)</code></a>.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#acos-float-">acos</a></span>(float&nbsp;n)</code>
<div class="block">Arc cosine approximation with very low error, based on a simplified version of <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2-float-float-"><code>atan2(float, float)</code></a>.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#asin_-double-">asin_</a></span>(double&nbsp;n)</code>
<div class="block">Inverse sine function (arcsine) but with output measured in turns instead of radians.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#asin_-float-">asin_</a></span>(float&nbsp;n)</code>
<div class="block">Inverse sine function (arcsine) but with output measured in turns instead of radians.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#asin-double-">asin</a></span>(double&nbsp;n)</code>
<div class="block">Arc sine approximation with very low error, based on a simplified version of <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2-float-float-"><code>atan2(float, float)</code></a>.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#asin-float-">asin</a></span>(float&nbsp;n)</code>
<div class="block">Arc sine approximation with very low error, based on a simplified version of <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2-double-double-"><code>atan2(double, double)</code></a>.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2_-double-double-">atan2_</a></span>(double&nbsp;y,
      double&nbsp;x)</code>
<div class="block">Altered-range approximation of the frequently-used trigonometric method atan2, taking y and x positions as 
 doubles and returning an angle measured in turns from 0.0 to 1.0 (inclusive), with one cycle over the range
 equivalent to 360 degrees or 2PI radians.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2_-float-float-">atan2_</a></span>(float&nbsp;y,
      float&nbsp;x)</code>
<div class="block">Altered-range approximation of the frequently-used trigonometric method atan2, taking y and x positions as floats
 and returning an angle measured in turns from 0.0f to 1.0f, with one cycle over the range equivalent to 360
 degrees or 2PI radians.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2-double-double-">atan2</a></span>(double&nbsp;y,
     double&nbsp;x)</code>
<div class="block">Close approximation of the frequently-used trigonometric method atan2, with higher precision than libGDX's atan2
 approximation.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2-float-float-">atan2</a></span>(float&nbsp;y,
     float&nbsp;x)</code>
<div class="block">Close approximation of the frequently-used trigonometric method atan2, with higher precision than libGDX's atan2
 approximation.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2Degrees-double-double-">atan2Degrees</a></span>(double&nbsp;y,
            double&nbsp;x)</code>
<div class="block">Close approximation of the frequently-used trigonometric method atan2, with higher precision than libGDX's atan2
 approximation, and giving a result in degrees from -180 to 180.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2Degrees-float-float-">atan2Degrees</a></span>(float&nbsp;y,
            float&nbsp;x)</code>
<div class="block">Close approximation of the frequently-used trigonometric method atan2, with higher precision than libGDX's atan2
 approximation, and giving a result in degrees from -180 to 180.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2Degrees360-double-double-">atan2Degrees360</a></span>(double&nbsp;y,
               double&nbsp;x)</code>
<div class="block">Close approximation of the frequently-used trigonometric method atan2, with higher precision than libGDX's atan2
 approximation, and giving a result in degrees from 0 to 360 (both inclusive).</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2Degrees360-float-float-">atan2Degrees360</a></span>(float&nbsp;y,
               float&nbsp;x)</code>
<div class="block">Close approximation of the frequently-used trigonometric method atan2, with higher precision than libGDX's atan2
 approximation, and giving a result in degrees from 0 to 360 (both inclusive).</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#cos_-double-">cos_</a></span>(double&nbsp;turns)</code>
<div class="block">A variation on <code>Math.cos(double)</code> that takes its input as a fraction of a turn instead of in radians; one
 turn is equal to 360 degrees or two*PI radians.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#cos_-float-">cos_</a></span>(float&nbsp;turns)</code>
<div class="block">A variation on <code>Math.cos(double)</code> that takes its input as a fraction of a turn instead of in radians (it
 also takes and returns a float); one turn is equal to 360 degrees or two*PI radians.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#cos-double-">cos</a></span>(double&nbsp;radians)</code>
<div class="block">A fairly-close approximation of <code>Math.cos(double)</code> that can be significantly faster (between 8x and 80x
 faster cos() calls in benchmarking; if you have access to libGDX you should consider its sometimes-more-precise
 and sometimes-faster MathUtils.cos() method.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#cos-float-">cos</a></span>(float&nbsp;radians)</code>
<div class="block">A fairly-close approximation of <code>Math.cos(double)</code> that can be significantly faster (between 8x and 80x
 faster cos() calls in benchmarking, and both takes and returns floats; if you have access to libGDX you should
 consider its more-precise and sometimes-faster MathUtils.cos() method.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#cosDegrees-float-">cosDegrees</a></span>(float&nbsp;degrees)</code>
<div class="block">A fairly-close approximation of <code>Math.cos(double)</code> that can be significantly faster (between 8x and 80x
 faster cos() calls in benchmarking, and both takes and returns floats; if you have access to libGDX, you should
 consider its more-precise and sometimes-faster MathUtils.cosDeg() method.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#lowestOneBit-int-">lowestOneBit</a></span>(int&nbsp;num)</code>
<div class="block">Returns an int value with at most a single one-bit, in the position of the lowest-order ("rightmost") one-bit in
 the specified int value.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#lowestOneBit-long-">lowestOneBit</a></span>(long&nbsp;num)</code>
<div class="block">Returns an long value with at most a single one-bit, in the position of the lowest-order ("rightmost") one-bit in
 the specified long value.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#sin_-double-">sin_</a></span>(double&nbsp;turns)</code>
<div class="block">A variation on <code>Math.sin(double)</code> that takes its input as a fraction of a turn instead of in radians; one
 turn is equal to 360 degrees or two*PI radians.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#sin_-float-">sin_</a></span>(float&nbsp;turns)</code>
<div class="block">A variation on <code>Math.sin(double)</code> that takes its input as a fraction of a turn instead of in radians (it
 also takes and returns a float); one turn is equal to 360 degrees or two*PI radians.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#sin-double-">sin</a></span>(double&nbsp;radians)</code>
<div class="block">A fairly-close approximation of <code>Math.sin(double)</code> that can be significantly faster (between 8x and 80x
 faster sin() calls in benchmarking; if you have access to libGDX you should consider its sometimes-more-precise
 and sometimes-faster MathUtils.sin() method.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#sin-float-">sin</a></span>(float&nbsp;radians)</code>
<div class="block">A fairly-close approximation of <code>Math.sin(double)</code> that can be significantly faster (between 8x and 80x
 faster sin() calls in benchmarking, and both takes and returns floats; if you have access to libGDX you should
 consider its more-precise and sometimes-faster MathUtils.sin() method.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/yellowstonegames/core/TrigTools.html#sinDegrees-float-">sinDegrees</a></span>(float&nbsp;degrees)</code>
<div class="block">A fairly-close approximation of <code>Math.sin(double)</code> that can be significantly faster (between 8x and 80x
 faster sin() calls in benchmarking, and both takes and returns floats; if you have access to libGDX, you should
 consider its more-precise and sometimes-faster MathUtils.sinDeg() method.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="TrigTools--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>TrigTools</h4>
<pre>public&nbsp;TrigTools()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="lowestOneBit-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lowestOneBit</h4>
<pre>public static&nbsp;int&nbsp;lowestOneBit(int&nbsp;num)</pre>
<div class="block">Returns an int value with at most a single one-bit, in the position of the lowest-order ("rightmost") one-bit in
 the specified int value. Returns zero if the specified value has no one-bits in its two's complement binary
 representation, that is, if it is equal to zero.
 <br>
 Identical to <code>Integer.lowestOneBit(int)</code>, but super-sourced to act correctly on GWT. If you have GWT as a
 target and do bit manipulation work, double-check everything! An int can be higher than <code>Integer.MAX_VALUE</code>
 or lower than <code>Integer.MIN_VALUE</code> on GWT, without actually being a long (internally it's a double). This
 is especially relevant for the overload of this method that takes and returns a long;
 <code>Long.lowestOneBit(long)</code> does not provide correct results for certain inputs on GWT, such as
 -17592186044416L, which it mysteriously returns 0L on, so you should use <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#lowestOneBit-long-"><code>lowestOneBit(long)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>num</code> - the value whose lowest one bit is to be computed</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an int value with a single one-bit, in the position of the lowest-order one-bit in the specified value,
         or zero if the specified value is itself equal to zero.</dd>
</dl>
</li>
</ul>
<a name="lowestOneBit-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lowestOneBit</h4>
<pre>public static&nbsp;long&nbsp;lowestOneBit(long&nbsp;num)</pre>
<div class="block">Returns an long value with at most a single one-bit, in the position of the lowest-order ("rightmost") one-bit in
 the specified long value. Returns zero if the specified value has no one-bits in its two's complement binary
 representation, that is, if it is equal to zero.
 <br>
 Identical to <code>Long.lowestOneBit(long)</code>, but super-sourced to act correctly on GWT. If you have GWT as a
 target and do bit manipulation work, double-check everything! An int can be higher than <code>Integer.MAX_VALUE</code>
 or lower than <code>Integer.MIN_VALUE</code> on GWT, without actually being a long (internally it's a double). This
 is especially relevant for this overload (for longs more so than for ints); <code>Long.lowestOneBit(long)</code> does
 not provide correct results for certain inputs on GWT, such as -17592186044416L, which it mysteriously returns 0L
 on, so you should use this method.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>num</code> - the value whose lowest one bit is to be computed</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a long value with a single one-bit, in the position of the lowest-order one-bit in the specified value,
         or zero if the specified value is itself equal to zero.</dd>
</dl>
</li>
</ul>
<a name="sin-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sin</h4>
<pre>public static&nbsp;double&nbsp;sin(double&nbsp;radians)</pre>
<div class="block">A fairly-close approximation of <code>Math.sin(double)</code> that can be significantly faster (between 8x and 80x
 faster sin() calls in benchmarking; if you have access to libGDX you should consider its sometimes-more-precise
 and sometimes-faster MathUtils.sin() method. Because this method doesn't rely on a
 lookup table, where libGDX's MathUtils does, applications that have a bottleneck on memory may perform better
 with this method than with MathUtils. Takes the same arguments Math.sin() does, so one angle in radians,
 which may technically be any double (but this will lose precision on fairly large doubles, such as those that are
 larger than <code>Long.MAX_VALUE</code>, because those doubles themselves will lose precision at that scale). The
 difference between the result of this method and <code>Math.sin(double)</code> should be under 0.0011 at
 all points between -pi and pi, with an average difference of about 0.0005; not all points have been checked for
 potentially higher errors, though.
 <br>
 The error for this double version is extremely close to the float version, <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#sin-float-"><code>sin(float)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 Unlike in previous versions of this method, the sign of the input doesn't affect performance here, at least not
 by a measurable amount.
 <br>
 The technique for sine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any double to the valid input range.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>radians</code> - an angle in radians as a double, often from 0 to pi * 2, though not required to be.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the sine of the given angle, as a double between -1.0 and 1.0 (both inclusive)</dd>
</dl>
</li>
</ul>
<a name="cos-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cos</h4>
<pre>public static&nbsp;double&nbsp;cos(double&nbsp;radians)</pre>
<div class="block">A fairly-close approximation of <code>Math.cos(double)</code> that can be significantly faster (between 8x and 80x
 faster cos() calls in benchmarking; if you have access to libGDX you should consider its sometimes-more-precise
 and sometimes-faster MathUtils.cos() method. Because this method doesn't rely on a
 lookup table, where libGDX's MathUtils does, applications that have a bottleneck on memory may perform better
 with this method than with MathUtils. Takes the same arguments Math.cos() does, so one angle in radians,
 which may technically be any double (but this will lose precision on fairly large doubles, such as those that are
 larger than <code>Long.MAX_VALUE</code>, because those doubles themselves will lose precision at that scale). The
 difference between the result of this method and <code>Math.cos(double)</code> should be under 0.0011 at
 all points between -pi and pi, with an average difference of about 0.0005; not all points have been checked for
 potentially higher errors, though.
 <br>
 The error for this double version is extremely close to the float version, <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#cos-float-"><code>cos(float)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 Unlike in previous versions of this method, the sign of the input doesn't affect performance here, at least not
 by a measurable amount.
 The technique for cosine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any double to the valid input range.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>radians</code> - an angle in radians as a double, often from 0 to pi * 2, though not required to be.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the cosine of the given angle, as a double between -1.0 and 1.0 (both inclusive)</dd>
</dl>
</li>
</ul>
<a name="sin-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sin</h4>
<pre>public static&nbsp;float&nbsp;sin(float&nbsp;radians)</pre>
<div class="block">A fairly-close approximation of <code>Math.sin(double)</code> that can be significantly faster (between 8x and 80x
 faster sin() calls in benchmarking, and both takes and returns floats; if you have access to libGDX you should
 consider its more-precise and sometimes-faster MathUtils.sin() method. Because this method doesn't rely on a
 lookup table, where libGDX's MathUtils does, applications that have a bottleneck on memory may perform better
 with this method than with MathUtils. Takes the same arguments Math.sin() does, so one angle in radians,
 which may technically be any float (but this will lose precision on fairly large floats, such as those that are
 larger than <code>Integer.MAX_VALUE</code>, because those floats themselves will lose precision at that scale). The
 difference between the result of this method and <code>Math.sin(double)</code> should be under 0.0011 at
 all points between -pi and pi, with an average difference of about 0.0005; not all points have been checked for
 potentially higher errors, though.
 <br>
 The error for this float version is extremely close to the double version, <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#sin-double-"><code>sin(double)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 Unlike in previous versions of this method, the sign of the input doesn't affect performance here, at least not
 by a measurable amount.
 <br>
 The technique for sine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any float to the valid input range.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>radians</code> - an angle in radians as a float, often from 0 to pi * 2, though not required to be.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the sine of the given angle, as a float between -1f and 1f (both inclusive)</dd>
</dl>
</li>
</ul>
<a name="cos-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cos</h4>
<pre>public static&nbsp;float&nbsp;cos(float&nbsp;radians)</pre>
<div class="block">A fairly-close approximation of <code>Math.cos(double)</code> that can be significantly faster (between 8x and 80x
 faster cos() calls in benchmarking, and both takes and returns floats; if you have access to libGDX you should
 consider its more-precise and sometimes-faster MathUtils.cos() method. Because this method doesn't rely on a
 lookup table, where libGDX's MathUtils does, applications that have a bottleneck on memory may perform better
 with this method than with MathUtils. Takes the same arguments Math.cos() does, so one angle in radians,
 which may technically be any float (but this will lose precision on fairly large floats, such as those that are
 larger than <code>Integer.MAX_VALUE</code>, because those floats themselves will lose precision at that scale). The
 difference between the result of this method and <code>Math.cos(double)</code> should be under 0.0011 at
 all points between -pi and pi, with an average difference of about 0.0005; not all points have been checked for
 potentially higher errors, though.
 <br>
 The error for this float version is extremely close to the double version, <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#cos-double-"><code>cos(double)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 Unlike in previous versions of this method, the sign of the input doesn't affect performance here, at least not
 by a measurable amount.
 <br>
 The technique for cosine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any float to the valid input range.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>radians</code> - an angle in radians as a float, often from 0 to pi * 2, though not required to be.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the cosine of the given angle, as a float between -1f and 1f (both inclusive)</dd>
</dl>
</li>
</ul>
<a name="sinDegrees-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sinDegrees</h4>
<pre>public static&nbsp;float&nbsp;sinDegrees(float&nbsp;degrees)</pre>
<div class="block">A fairly-close approximation of <code>Math.sin(double)</code> that can be significantly faster (between 8x and 80x
 faster sin() calls in benchmarking, and both takes and returns floats; if you have access to libGDX, you should
 consider its more-precise and sometimes-faster MathUtils.sinDeg() method. Because this method doesn't rely on a
 lookup table, where libGDX's MathUtils does, applications that have a bottleneck on memory may perform better
 with this method than with MathUtils. Takes one angle in degrees,
 which may technically be any float (but this will lose precision on fairly large floats, such as those that are
 larger than <code>Integer.MAX_VALUE</code>, because those floats themselves will lose precision at that scale). The
 difference between the result of this method and <code>Math.sin(double)</code> should be under 0.0011 at
 all points between -360 and 360, with an average difference of about 0.0005; not all points have been checked for
 potentially higher errors, though.
 <br>
 The error for this float version is extremely close to the double version, <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#sin-double-"><code>sin(double)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 Unlike in previous versions of this method, the sign of the input doesn't affect performance here, at least not
 by a measurable amount.
 <br>
 The technique for sine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any float to the valid input range.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>degrees</code> - an angle in degrees as a float, often from 0 to 360, though not required to be.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the sine of the given angle, as a float between -1f and 1f (both inclusive)</dd>
</dl>
</li>
</ul>
<a name="cosDegrees-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cosDegrees</h4>
<pre>public static&nbsp;float&nbsp;cosDegrees(float&nbsp;degrees)</pre>
<div class="block">A fairly-close approximation of <code>Math.cos(double)</code> that can be significantly faster (between 8x and 80x
 faster cos() calls in benchmarking, and both takes and returns floats; if you have access to libGDX, you should
 consider its more-precise and sometimes-faster MathUtils.cosDeg() method. Because this method doesn't rely on a
 lookup table, where libGDX's MathUtils does, applications that have a bottleneck on memory may perform better
 with this method than with MathUtils. Takes one angle in degrees,
 which may technically be any float (but this will lose precision on fairly large floats, such as those that are
 larger than <code>Integer.MAX_VALUE</code>, because those floats themselves will lose precision at that scale). The
 difference between the result of this method and <code>Math.cos(double)</code> should be under 0.0011 at
 all points between -360 and 360, with an average difference of about 0.0005; not all points have been checked for
 potentially higher errors, though.
 <br>
 The error for this float version is extremely close to the double version, <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#cos-double-"><code>cos(double)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 Unlike in previous versions of this method, the sign of the input doesn't affect performance here, at least not
 by a measurable amount.
 <br>
 The technique for cosine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any float to the valid input range.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>degrees</code> - an angle in degrees as a float, often from 0 to pi * 2, though not required to be.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the cosine of the given angle, as a float between -1f and 1f (both inclusive)</dd>
</dl>
</li>
</ul>
<a name="sin_-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sin_</h4>
<pre>public static&nbsp;double&nbsp;sin_(double&nbsp;turns)</pre>
<div class="block">A variation on <code>Math.sin(double)</code> that takes its input as a fraction of a turn instead of in radians; one
 turn is equal to 360 degrees or two*PI radians. This can be useful as a building block for other measurements;
 to make a sine method that takes its input in grad (with 400 grad equal to 360 degrees), you would just divide
 the grad value by 400.0 (or multiply it by 0.0025) and pass it to this method. Similarly for binary degrees, also
 called brad (with 256 brad equal to 360 degrees), you would divide by 256.0 or multiply by 0.00390625 before
 passing that value here. The brad case is especially useful because you can use a byte for any brad values, and
 adding up those brad values will wrap correctly (256 brad goes back to 0) while keeping perfect precision for the
 results (you still divide by 256.0 when you pass the brad value to this method).
 <br>
 The error for this double version is extremely close to the float version, <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#sin_-float-"><code>sin_(float)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 The technique for sine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any double to the valid input range.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>turns</code> - an angle as a fraction of a turn as a double, with 0.5 here equivalent to PI radians in <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#cos-double-"><code>cos(double)</code></a></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the sine of the given angle, as a double between -1.0 and 1.0 (both inclusive)</dd>
</dl>
</li>
</ul>
<a name="cos_-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cos_</h4>
<pre>public static&nbsp;double&nbsp;cos_(double&nbsp;turns)</pre>
<div class="block">A variation on <code>Math.cos(double)</code> that takes its input as a fraction of a turn instead of in radians; one
 turn is equal to 360 degrees or two*PI radians. This can be useful as a building block for other measurements;
 to make a cosine method that takes its input in grad (with 400 grad equal to 360 degrees), you would just divide
 the grad value by 400.0 (or multiply it by 0.0025) and pass it to this method. Similarly for binary degrees, also
 called brad (with 256 brad equal to 360 degrees), you would divide by 256.0 or multiply by 0.00390625 before
 passing that value here. The brad case is especially useful because you can use a byte for any brad values, and
 adding up those brad values will wrap correctly (256 brad goes back to 0) while keeping perfect precision for the
 results (you still divide by 256.0 when you pass the brad value to this method).
 <br>
 The error for this double version is extremely close to the float version, <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#cos_-float-"><code>cos_(float)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 The technique for cosine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any double to the valid input range.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>turns</code> - an angle as a fraction of a turn as a double, with 0.5 here equivalent to PI radians in <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#cos-double-"><code>cos(double)</code></a></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the cosine of the given angle, as a double between -1.0 and 1.0 (both inclusive)</dd>
</dl>
</li>
</ul>
<a name="sin_-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sin_</h4>
<pre>public static&nbsp;float&nbsp;sin_(float&nbsp;turns)</pre>
<div class="block">A variation on <code>Math.sin(double)</code> that takes its input as a fraction of a turn instead of in radians (it
 also takes and returns a float); one turn is equal to 360 degrees or two*PI radians. This can be useful as a
 building block for other measurements; to make a sine method that takes its input in grad (with 400 grad equal to
 360 degrees), you would just divide the grad value by 400.0 (or multiply it by 0.0025) and pass it to this
 method. Similarly for binary degrees, also called brad (with 256 brad equal to 360 degrees), you would divide by
 256.0 or multiply by 0.00390625 before passing that value here. The brad case is especially useful because you
 can use a byte for any brad values, and adding up those brad values will wrap correctly (256 brad goes back to 0)
 while keeping perfect precision for the results (you still divide by 256.0 when you pass the brad value to this
 method).
 <br>
 The error for this float version is extremely close to the double version, <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#sin_-double-"><code>sin_(double)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 The technique for sine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any double to the valid input range.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>turns</code> - an angle as a fraction of a turn as a float, with 0.5 here equivalent to PI radians in <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#cos-double-"><code>cos(double)</code></a></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the sine of the given angle, as a float between -1.0 and 1.0 (both inclusive)</dd>
</dl>
</li>
</ul>
<a name="cos_-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cos_</h4>
<pre>public static&nbsp;float&nbsp;cos_(float&nbsp;turns)</pre>
<div class="block">A variation on <code>Math.cos(double)</code> that takes its input as a fraction of a turn instead of in radians (it
 also takes and returns a float); one turn is equal to 360 degrees or two*PI radians. This can be useful as a
 building block for other measurements; to make a cosine method that takes its input in grad (with 400 grad equal
 to 360 degrees), you would just divide the grad value by 400.0 (or multiply it by 0.0025) and pass it to this
 method. Similarly for binary degrees, also called brad (with 256 brad equal to 360 degrees), you would divide by
 256.0 or multiply by 0.00390625 before passing that value here. The brad case is especially useful because you
 can use a byte for any brad values, and adding up those brad values will wrap correctly (256 brad goes back to 0)
 while keeping perfect precision for the results (you still divide by 256.0 when you pass the brad value to this
 method).
 <br>
 The error for this float version is extremely close to the float version, <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#cos_-double-"><code>cos_(double)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 The technique for cosine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any double to the valid input range.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>turns</code> - an angle as a fraction of a turn as a float, with 0.5 here equivalent to PI radians in <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#cos-double-"><code>cos(double)</code></a></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the cosine of the given angle, as a float between -1.0 and 1.0 (both inclusive)</dd>
</dl>
</li>
</ul>
<a name="atan2-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>atan2</h4>
<pre>public static&nbsp;double&nbsp;atan2(double&nbsp;y,
                           double&nbsp;x)</pre>
<div class="block">Close approximation of the frequently-used trigonometric method atan2, with higher precision than libGDX's atan2
 approximation. Maximum error is below 0.001 radians.
 Takes y and x (in that unusual order) as doubles, and returns the angle from the origin to that point in radians.
 It is about 5 times faster than <code>Math.atan2(double, double)</code> (roughly 17 ns instead of roughly 88 ns for
 Math, though the computer was under some load during testing). It is almost identical in speed to libGDX'
 MathUtils approximation of the same method; MathUtils seems to have worse average error, though.
 Credit to Nic Taylor and imuli, with Taylor publishing
 <a href="https://www.dsprelated.com/showarticle/1052.php">this nice post</a> and imuli commenting with very
 handy information that makes this approach usable. This method changed from an earlier
 technique that was twice as fast but had very poor quality, enough to be visually noticeable. See also
 <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2_-double-double-"><code>atan2_(double, double)</code></a> if you don't want a mess converting to degrees or some other measurement, since
 that method returns an angle from 0.0 (equal to 0 degrees) to 1.0 (equal to 360 degrees).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>y</code> - y-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dd><code>x</code> - x-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the angle to the given point, in radians as a double; ranges from -PI to PI</dd>
</dl>
</li>
</ul>
<a name="atan2-float-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>atan2</h4>
<pre>public static&nbsp;float&nbsp;atan2(float&nbsp;y,
                          float&nbsp;x)</pre>
<div class="block">Close approximation of the frequently-used trigonometric method atan2, with higher precision than libGDX's atan2
 approximation. Maximum error is below 0.001 radians.
 Takes y and x (in that unusual order) as floats, and returns the angle from the origin to that point in radians.
 It is about 5 times faster than <code>Math.atan2(double, double)</code> (roughly 17 ns instead of roughly 88 ns for
 Math, though the computer was under some load during testing). It is almost identical in speed to libGDX'
 MathUtils approximation of the same method; MathUtils seems to have worse average error, though.
 Credit to Nic Taylor and imuli, with Taylor publishing
 <a href="https://www.dsprelated.com/showarticle/1052.php">this nice post</a> and imuli commenting with very
 handy information that makes this approach usable. This method changed from an earlier
 technique that was twice as fast but had very poor quality, enough to be visually noticeable. See also
 <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2_-float-float-"><code>atan2_(float, float)</code></a> if you don't want a mess converting to degrees or some other measurement, since
 that method returns an angle from 0f (equal to 0 degrees) to 1f (equal to 360 degrees).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>y</code> - y-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dd><code>x</code> - x-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the angle to the given point, in radians as a float; ranges from -PI to PI</dd>
</dl>
</li>
</ul>
<a name="atan2_-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>atan2_</h4>
<pre>public static&nbsp;double&nbsp;atan2_(double&nbsp;y,
                            double&nbsp;x)</pre>
<div class="block">Altered-range approximation of the frequently-used trigonometric method atan2, taking y and x positions as 
 doubles and returning an angle measured in turns from 0.0 to 1.0 (inclusive), with one cycle over the range
 equivalent to 360 degrees or 2PI radians. You can multiply the angle by <code>6.2831855f</code> to change to radians,
 or by <code>360f</code> to change to degrees. Takes y and x (in that unusual order) as doubles. Will never return a
 negative number, which may help avoid costly floating-point modulus when you actually want a positive number.
 Credit to Nic Taylor and imuli, with Taylor publishing
 <a href="https://www.dsprelated.com/showarticle/1052.php">this nice post</a> and imuli commenting with very
 handy information that makes this approach usable. Note that
 <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2-double-double-"><code>atan2(double, double)</code></a> returns an angle in radians and can return negative results, which may be fine for
 many tasks; these two methods are extremely close in implementation and speed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>y</code> - y-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dd><code>x</code> - x-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the angle to the given point, as a double from 0.0 to 1.0, inclusive</dd>
</dl>
</li>
</ul>
<a name="atan2_-float-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>atan2_</h4>
<pre>public static&nbsp;float&nbsp;atan2_(float&nbsp;y,
                           float&nbsp;x)</pre>
<div class="block">Altered-range approximation of the frequently-used trigonometric method atan2, taking y and x positions as floats
 and returning an angle measured in turns from 0.0f to 1.0f, with one cycle over the range equivalent to 360
 degrees or 2PI radians. You can multiply the angle by <code>6.2831855f</code> to change to radians, or by <code>360f</code>
 to change to degrees. Takes y and x (in that unusual order) as floats. Will never return a negative number, which
 may help avoid costly floating-point modulus when you actually want a positive number.
 Credit to Nic Taylor and imuli, with Taylor publishing
 <a href="https://www.dsprelated.com/showarticle/1052.php">this nice post</a> and imuli commenting with very
 handy information that makes this approach usable. Note that
 <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2-float-float-"><code>atan2(float, float)</code></a> returns an angle in radians and can return negative results, which may be fine for
 many tasks; these two methods are extremely close in implementation and speed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>y</code> - y-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dd><code>x</code> - x-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the angle to the given point, as a float from 0.0f to 1.0f, inclusive</dd>
</dl>
</li>
</ul>
<a name="atan2Degrees-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>atan2Degrees</h4>
<pre>public static&nbsp;double&nbsp;atan2Degrees(double&nbsp;y,
                                  double&nbsp;x)</pre>
<div class="block">Close approximation of the frequently-used trigonometric method atan2, with higher precision than libGDX's atan2
 approximation, and giving a result in degrees from -180 to 180. Maximum error is below 0.1 degrees.
 Takes y and x (in that unusual order) as doubles, and returns the angle from the origin to that point in degrees.
 It is about 5 times faster than <code>Math.atan2(double, double)</code> (roughly 17 ns instead of roughly 88 ns for
 Math, though the computer was under some load during testing). It is almost identical in speed to libGDX'
 MathUtils approximation after converting to degrees; MathUtils seems to have worse average error, though.
 Credit to Nic Taylor and imuli, with Taylor publishing
 <a href="https://www.dsprelated.com/showarticle/1052.php">this nice post</a> and imuli commenting with very
 handy information that makes this approach usable.
 <br>
 See also <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2Degrees360-double-double-"><code>atan2Degrees360(double, double)</code></a>, which is just like this but returns an angle from 0 to 360,
 instead of -180 to 180, in case negative angles are undesirable.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>y</code> - y-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dd><code>x</code> - x-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the angle to the given point, in degrees as a double</dd>
</dl>
</li>
</ul>
<a name="atan2Degrees-float-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>atan2Degrees</h4>
<pre>public static&nbsp;float&nbsp;atan2Degrees(float&nbsp;y,
                                 float&nbsp;x)</pre>
<div class="block">Close approximation of the frequently-used trigonometric method atan2, with higher precision than libGDX's atan2
 approximation, and giving a result in degrees from -180 to 180. Maximum error is below 0.1 degrees.
 Takes y and x (in that unusual order) as floats, and returns the angle from the origin to that point in degrees.
 It is about 5 times faster than <code>Math.atan2(double, double)</code> (roughly 17 ns instead of roughly 88 ns for
 Math, though the computer was under some load during testing). It is almost identical in speed to libGDX'
 MathUtils approximation after converting to degrees; MathUtils seems to have worse average error, though.
 Credit to Nic Taylor and imuli, with Taylor publishing
 <a href="https://www.dsprelated.com/showarticle/1052.php">this nice post</a> and imuli commenting with very
 handy information that makes this approach usable.
 <br>
 See also <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2Degrees360-float-float-"><code>atan2Degrees360(float, float)</code></a>, which is just like this but returns an angle from 0 to 360,
 instead of -180 to 180, in case negative angles are undesirable.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>y</code> - y-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dd><code>x</code> - x-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the angle to the given point, in degrees as a float</dd>
</dl>
</li>
</ul>
<a name="atan2Degrees360-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>atan2Degrees360</h4>
<pre>public static&nbsp;double&nbsp;atan2Degrees360(double&nbsp;y,
                                     double&nbsp;x)</pre>
<div class="block">Close approximation of the frequently-used trigonometric method atan2, with higher precision than libGDX's atan2
 approximation, and giving a result in degrees from 0 to 360 (both inclusive). Maximum error is below 0.1 degrees.
 Takes y and x (in that unusual order) as doubles, and returns the angle from the origin to that point in degrees.
 It is about 5 times faster than <code>Math.atan2(double, double)</code> (roughly 17 ns instead of roughly 88 ns for
 Math, though the computer was under some load during testing). It is almost identical in speed to libGDX'
 MathUtils approximation after converting to degrees; MathUtils seems to have worse average error, though.
 Credit to Nic Taylor and imuli, with Taylor publishing
 <a href="https://www.dsprelated.com/showarticle/1052.php">this nice post</a> and imuli commenting with very
 handy information that makes this approach usable.
 <br>
 See also <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2Degrees-double-double-"><code>atan2Degrees(double, double)</code></a>, which is just like this but returns an angle from -180 to 180,
 matching <code>Math.atan2(double, double)</code>'s convention.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>y</code> - y-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dd><code>x</code> - x-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the angle to the given point, in degrees as a double</dd>
</dl>
</li>
</ul>
<a name="atan2Degrees360-float-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>atan2Degrees360</h4>
<pre>public static&nbsp;float&nbsp;atan2Degrees360(float&nbsp;y,
                                    float&nbsp;x)</pre>
<div class="block">Close approximation of the frequently-used trigonometric method atan2, with higher precision than libGDX's atan2
 approximation, and giving a result in degrees from 0 to 360 (both inclusive). Maximum error is below 0.1 degrees.
 Takes y and x (in that unusual order) as floats, and returns the angle from the origin to that point in degrees.
 It is about 5 times faster than <code>Math.atan2(double, double)</code> (roughly 17 ns instead of roughly 88 ns for
 Math, though the computer was under some load during testing). It is almost identical in speed to libGDX'
 MathUtils approximation after converting to degrees; MathUtils seems to have worse average error, though.
 Credit to Nic Taylor and imuli, with Taylor publishing
 <a href="https://www.dsprelated.com/showarticle/1052.php">this nice post</a> and imuli commenting with very
 handy information that makes this approach usable.
 <br>
 See also <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2Degrees-float-float-"><code>atan2Degrees(float, float)</code></a>, which is just like this but returns an angle from -180 to 180,
 matching <code>Math.atan2(double, double)</code>'s convention.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>y</code> - y-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dd><code>x</code> - x-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the angle to the given point, in degrees as a float</dd>
</dl>
</li>
</ul>
<a name="asin-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asin</h4>
<pre>public static&nbsp;float&nbsp;asin(float&nbsp;n)</pre>
<div class="block">Arc sine approximation with very low error, based on a simplified version of <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2-double-double-"><code>atan2(double, double)</code></a>.
 This method is usually much faster than <code>Math.asin(double)</code>, but is somewhat less precise than Math's
 implementation). It is currently more precise than libGDX's approximation in their MathUtils, but this isn't
 quite as fast; the difference in precision is hard to spot but can be noticeable in some usage.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>n</code> - an input to the inverse sine function, from -1 to 1 inclusive</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an output from the inverse sine function, from PI/-2.0 to PI/2.0 inclusive.</dd>
</dl>
</li>
</ul>
<a name="asin-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asin</h4>
<pre>public static&nbsp;double&nbsp;asin(double&nbsp;n)</pre>
<div class="block">Arc sine approximation with very low error, based on a simplified version of <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2-float-float-"><code>atan2(float, float)</code></a>.
 This method is usually much faster than <code>Math.asin(double)</code>, but is somewhat less precise than Math's
 implementation). It is currently more precise than libGDX's approximation in their MathUtils, but this isn't
 quite as fast; the difference in precision is hard to spot but can be noticeable in some usage.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>n</code> - an input to the inverse sine function, from -1 to 1 inclusive</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an output from the inverse sine function, from PI/-2.0 to PI/2.0 inclusive.</dd>
</dl>
</li>
</ul>
<a name="acos-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>acos</h4>
<pre>public static&nbsp;double&nbsp;acos(double&nbsp;n)</pre>
<div class="block">Arc cosine approximation with very low error, based on a simplified version of <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2-double-double-"><code>atan2(double, double)</code></a>.
 This method is usually much faster than <code>Math.acos(double)</code>, but is somewhat less precise than Math's
 implementation). It is currently more precise than libGDX's approximation in their MathUtils, but this isn't
 quite as fast; the difference in precision is hard to spot but can be noticeable in some usage.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>n</code> - an input to the inverse cosine function, from -1 to 1 inclusive</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an output from the inverse cosine function, from 0 to PI inclusive.</dd>
</dl>
</li>
</ul>
<a name="acos-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>acos</h4>
<pre>public static&nbsp;float&nbsp;acos(float&nbsp;n)</pre>
<div class="block">Arc cosine approximation with very low error, based on a simplified version of <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#atan2-float-float-"><code>atan2(float, float)</code></a>.
 This method is usually much faster than <code>Math.acos(double)</code>, but is somewhat less precise than Math's
 implementation). It is currently more precise than libGDX's approximation in their MathUtils, but this isn't
 quite as fast; the difference in precision is hard to spot but can be noticeable in some usage.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>n</code> - an input to the inverse cosine function, from -1 to 1 inclusive</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an output from the inverse cosine function, from 0 to PI inclusive.</dd>
</dl>
</li>
</ul>
<a name="asin_-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asin_</h4>
<pre>public static&nbsp;double&nbsp;asin_(double&nbsp;n)</pre>
<div class="block">Inverse sine function (arcsine) but with output measured in turns instead of radians. Possible results for this
 range from 0.75 (inclusive) to 1.0 (exclusive), and continuing past that to 0.0 (inclusive) to 0.25 (inclusive).
 <br>
 This method is extremely similar to the non-turn approximation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>n</code> - a double from -1.0 to 1.0 (both inclusive), usually the output of sin_() or cos_()</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>one of the values that would produce <code>n</code> if it were passed to <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#sin_-double-"><code>sin_(double)</code></a></dd>
</dl>
</li>
</ul>
<a name="acos_-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>acos_</h4>
<pre>public static&nbsp;double&nbsp;acos_(double&nbsp;n)</pre>
<div class="block">Inverse cosine function (arccos) but with output measured in turns instead of radians. Possible results for this
 range from 0.0 (inclusive) to 0.5 (inclusive).
 <br>
 This method is extremely similar to the non-turn approximation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>n</code> - a double from -1.0 to 1.0 (both inclusive), usually the output of sin_() or cos_()</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>one of the values that would produce <code>n</code> if it were passed to <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#cos_-double-"><code>cos_(double)</code></a></dd>
</dl>
</li>
</ul>
<a name="asin_-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asin_</h4>
<pre>public static&nbsp;float&nbsp;asin_(float&nbsp;n)</pre>
<div class="block">Inverse sine function (arcsine) but with output measured in turns instead of radians. Possible results for this
 range from 0.75f (inclusive) to 1.0f (exclusive), and continuing past that to 0.0f (inclusive) to 0.25f
 (inclusive).
 <br>
 This method is extremely similar to the non-turn approximation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>n</code> - a float from -1.0f to 1.0f (both inclusive), usually the output of sin_() or cos_()</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>one of the values that would produce <code>n</code> if it were passed to <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#sin_-float-"><code>sin_(float)</code></a></dd>
</dl>
</li>
</ul>
<a name="acos_-float-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>acos_</h4>
<pre>public static&nbsp;float&nbsp;acos_(float&nbsp;n)</pre>
<div class="block">Inverse cosine function (arccos) but with output measured in turns instead of radians. Possible results for this
 range from 0.0f (inclusive) to 0.5f (inclusive).
 <br>
 This method is extremely similar to the non-turn approximation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>n</code> - a float from -1.0f to 1.0f (both inclusive), usually the output of sin_() or cos_()</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>one of the values that would produce <code>n</code> if it were passed to <a href="../../../../com/github/yellowstonegames/core/TrigTools.html#cos_-float-"><code>cos_(float)</code></a></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../com/github/yellowstonegames/core/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../com/github/yellowstonegames/core/LZSEncoding.html" title="class in com.github.yellowstonegames.core"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li>Next&nbsp;Class</li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/github/yellowstonegames/core/TrigTools.html" target="_top">Frames</a></li>
<li><a href="TrigTools.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
