<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (16) -->
<title>TrigTools (squidcore 0.0.1-SNAPSHOT API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: com.github.yellowstonegames.core, class: TrigTools">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">com.github.yellowstonegames.core</a></div>
<h1 title="Class TrigTools" class="title">Class TrigTools</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">com.github.yellowstonegames.core.TrigTools</div>
</div>
<section class="description">
<hr>
<div class="type-signature"><span class="modifiers">public final class </span><span class="element-name type-name-label">TrigTools</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">Various fast trigonometric approximations that don't use a lookup table. Some of these are uncommon and useful, like
 <a href="#sin_(float)"><code>sin_(float)</code></a>, which takes an argument in turns instead of radians (1 turn equals 2PI radians).</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field.summary">
<h2>Field Summary</h2>
<div class="caption"><span>Fields</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Field</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static float</code></div>
<div class="col-second even-row-color"><code><span class="member-name-link"><a href="#HALF_PI">HALF_PI</a></span></code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><code>static float</code></div>
<div class="col-second odd-row-color"><code><span class="member-name-link"><a href="#PI">PI</a></span></code></div>
<div class="col-last odd-row-color">&nbsp;</div>
<div class="col-first even-row-color"><code>static float</code></div>
<div class="col-second even-row-color"><code><span class="member-name-link"><a href="#PI2">PI2</a></span></code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor.summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-constructor-name even-row-color"><code><span class="member-name-link"><a href="#%3Cinit%3E()">TrigTools</a></span>()</code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#acos(double)">acos</a></span>&#8203;(double&nbsp;x)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Arc cosine approximation with very low error, using an algorithm from the 1955 research study
 "Approximations for Digital Computers," by RAND Corporation (this is sheet 35's algorithm, which is the fastest
 and least precise).</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#acos(float)">acos</a></span>&#8203;(float&nbsp;x)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Arc cosine approximation with very low error, using an algorithm from the 1955 research study
 "Approximations for Digital Computers," by RAND Corporation (this is sheet 35's algorithm, which is the fastest
 and least precise).</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#acos_(double)">acos_</a></span>&#8203;(double&nbsp;x)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Inverse cosine function (arccos) but with output measured in turns instead of radians.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#acos_(float)">acos_</a></span>&#8203;(float&nbsp;x)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Inverse cosine function (arccos) but with output measured in turns instead of radians.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#asin(double)">asin</a></span>&#8203;(double&nbsp;x)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Arc sine approximation with very low error, using an algorithm from the 1955 research study
 "Approximations for Digital Computers," by RAND Corporation (this is sheet 35's algorithm, which is the fastest
 and least precise).</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#asin(float)">asin</a></span>&#8203;(float&nbsp;x)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Arc sine approximation with very low error, using an algorithm from the 1955 research study
 "Approximations for Digital Computers," by RAND Corporation (this is sheet 35's algorithm, which is the fastest
 and least precise).</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#asin_(double)">asin_</a></span>&#8203;(double&nbsp;x)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Inverse sine function (arcsine) but with output measured in turns instead of radians.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#asin_(float)">asin_</a></span>&#8203;(float&nbsp;x)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Inverse sine function (arcsine) but with output measured in turns instead of radians.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#atan(double)">atan</a></span>&#8203;(double&nbsp;i)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Arc tangent approximation with very low error, using an algorithm from the 1955 research study
 "Approximations for Digital Computers," by RAND Corporation (this is sheet 9's algorithm, which is the
 second-fastest and second-least precise).</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#atan(float)">atan</a></span>&#8203;(float&nbsp;i)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Arc tangent approximation with very low error, using an algorithm from the 1955 research study
 "Approximations for Digital Computers," by RAND Corporation (this is sheet 9's algorithm, which is the
 second-fastest and second-least precise).</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#atan2(double,double)">atan2</a></span>&#8203;(double&nbsp;y,
 double&nbsp;x)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Close approximation of the frequently-used trigonometric method atan2, with higher precision than libGDX's atan2
 approximation.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#atan2(float,float)">atan2</a></span>&#8203;(float&nbsp;y,
 float&nbsp;x)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Close approximation of the frequently-used trigonometric method atan2, with higher precision than libGDX's atan2
 approximation.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#atan2_(double,double)">atan2_</a></span>&#8203;(double&nbsp;y,
 double&nbsp;x)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Altered-range approximation of the frequently-used trigonometric method atan2, taking y and x positions as
 doubles and returning an angle measured in turns from 0.0 to 1.0 (inclusive), with one cycle over the range
 equivalent to 360 degrees or 2PI radians.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#atan2_(float,float)">atan2_</a></span>&#8203;(float&nbsp;y,
 float&nbsp;x)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Altered-range approximation of the frequently-used trigonometric method atan2, taking y and x positions as floats
 and returning an angle measured in turns from 0.0f to 1.0f, with one cycle over the range equivalent to 360
 degrees or 2PI radians.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#atan2Degrees(double,double)">atan2Degrees</a></span>&#8203;(double&nbsp;y,
 double&nbsp;x)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Close approximation of the frequently-used trigonometric method atan2 measured in degrees, with higher precision
 than libGDX's atan2 approximation.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#atan2Degrees(float,float)">atan2Degrees</a></span>&#8203;(float&nbsp;y,
 float&nbsp;x)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Close approximation of the frequently-used trigonometric method atan2 measured in degrees, with higher precision
 than libGDX's atan2 approximation.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#atan2Degrees360(double,double)">atan2Degrees360</a></span>&#8203;(double&nbsp;y,
 double&nbsp;x)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Altered-range approximation of the frequently-used trigonometric method atan2, taking y and x positions as
 doubles and returning an angle measured in turns from 0.0 to 360.0 (inclusive), with one cycle over the range
 equivalent to 2PI radians or 1 turn.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#atan2Degrees360(float,float)">atan2Degrees360</a></span>&#8203;(float&nbsp;y,
 float&nbsp;x)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Altered-range approximation of the frequently-used trigonometric method atan2, taking y and x positions as
 floats and returning an angle measured in turns from 0.0 to 360.0 (inclusive), with one cycle over the range
 equivalent to 2PI radians or 1 turn.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#atanDegrees(double)">atanDegrees</a></span>&#8203;(double&nbsp;i)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Arc tangent approximation measured in degrees, using an algorithm from the 1955 research study
 "Approximations for Digital Computers," by RAND Corporation (this is sheet 9's algorithm, which is the
 second-fastest and second-least precise).</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#atanDegrees(float)">atanDegrees</a></span>&#8203;(float&nbsp;i)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">Arc tangent approximation measured in degrees, using an algorithm from the 1955 research study
 "Approximations for Digital Computers," by RAND Corporation (this is sheet 9's algorithm, which is the
 second-fastest and second-least precise).</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#cos(double)">cos</a></span>&#8203;(double&nbsp;radians)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">A fairly-close approximation of <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#cos(double)" title="class or interface in java.lang" class="external-link"><code>Math.cos(double)</code></a> that can be significantly faster (between 8x and 80x
 faster cos() calls in benchmarking; if you have access to libGDX you should consider its sometimes-more-precise
 and sometimes-faster MathUtils.cos() method.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#cos(float)">cos</a></span>&#8203;(float&nbsp;radians)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">A fairly-close approximation of <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#cos(double)" title="class or interface in java.lang" class="external-link"><code>Math.cos(double)</code></a> that can be significantly faster (between 8x and 80x
 faster cos() calls in benchmarking, and both takes and returns floats; if you have access to libGDX you should
 consider its more-precise and sometimes-faster MathUtils.cos() method.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#cos_(double)">cos_</a></span>&#8203;(double&nbsp;turns)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">A variation on <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#cos(double)" title="class or interface in java.lang" class="external-link"><code>Math.cos(double)</code></a> that takes its input as a fraction of a turn instead of in radians; one
 turn is equal to 360 degrees or two*PI radians.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#cos_(float)">cos_</a></span>&#8203;(float&nbsp;turns)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">A variation on <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#cos(double)" title="class or interface in java.lang" class="external-link"><code>Math.cos(double)</code></a> that takes its input as a fraction of a turn instead of in radians (it
 also takes and returns a float); one turn is equal to 360 degrees or two*PI radians.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#cosDegrees(double)">cosDegrees</a></span>&#8203;(double&nbsp;degrees)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">A fairly-close approximation of <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#cos(double)" title="class or interface in java.lang" class="external-link"><code>Math.cos(double)</code></a> that can be significantly faster (between 8x and 80x
 faster cos() calls in benchmarking, and both takes and returns floats; if you have access to libGDX, you should
 consider its more-precise and sometimes-faster MathUtils.cosDeg() method.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#cosDegrees(float)">cosDegrees</a></span>&#8203;(float&nbsp;degrees)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">A fairly-close approximation of <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#cos(double)" title="class or interface in java.lang" class="external-link"><code>Math.cos(double)</code></a> that can be significantly faster (between 8x and 80x
 faster cos() calls in benchmarking, and both takes and returns floats; if you have access to libGDX, you should
 consider its more-precise and sometimes-faster MathUtils.cosDeg() method.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#sin(double)">sin</a></span>&#8203;(double&nbsp;radians)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">A fairly-close approximation of <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#sin(double)" title="class or interface in java.lang" class="external-link"><code>Math.sin(double)</code></a> that can be significantly faster (between 8x and 80x
 faster sin() calls in benchmarking; if you have access to libGDX you should consider its sometimes-more-precise
 and sometimes-faster MathUtils.sin() method.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#sin(float)">sin</a></span>&#8203;(float&nbsp;radians)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">A fairly-close approximation of <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#sin(double)" title="class or interface in java.lang" class="external-link"><code>Math.sin(double)</code></a> that can be significantly faster (between 8x and 80x
 faster sin() calls in benchmarking, and both takes and returns floats; if you have access to libGDX you should
 consider its more-precise and sometimes-faster MathUtils.sin() method.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#sin_(double)">sin_</a></span>&#8203;(double&nbsp;turns)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">A variation on <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#sin(double)" title="class or interface in java.lang" class="external-link"><code>Math.sin(double)</code></a> that takes its input as a fraction of a turn instead of in radians; one
 turn is equal to 360 degrees or two*PI radians.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#sin_(float)">sin_</a></span>&#8203;(float&nbsp;turns)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">A variation on <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#sin(double)" title="class or interface in java.lang" class="external-link"><code>Math.sin(double)</code></a> that takes its input as a fraction of a turn instead of in radians (it
 also takes and returns a float); one turn is equal to 360 degrees or two*PI radians.</div>
</div>
<div class="col-first even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#sinDegrees(double)">sinDegrees</a></span>&#8203;(double&nbsp;degrees)</code></div>
<div class="col-last even-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">A fairly-close approximation of <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#sin(double)" title="class or interface in java.lang" class="external-link"><code>Math.sin(double)</code></a> that can be significantly faster (between 8x and 80x
 faster sin() calls in benchmarking, and both takes and returns floats; if you have access to libGDX, you should
 consider its more-precise and sometimes-faster MathUtils.sinDeg() method.</div>
</div>
<div class="col-first odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table"><code><span class="member-name-link"><a href="#sinDegrees(float)">sinDegrees</a></span>&#8203;(float&nbsp;degrees)</code></div>
<div class="col-last odd-row-color method-summary-table-tab1 method-summary-table-tab4 method-summary-table">
<div class="block">A fairly-close approximation of <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#sin(double)" title="class or interface in java.lang" class="external-link"><code>Math.sin(double)</code></a> that can be significantly faster (between 8x and 80x
 faster sin() calls in benchmarking, and both takes and returns floats; if you have access to libGDX, you should
 consider its more-precise and sometimes-faster MathUtils.sinDeg() method.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field.detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="PI">
<h3>PI</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">PI</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="../../../../constant-values.html#com.github.yellowstonegames.core.TrigTools.PI">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="HALF_PI">
<h3>HALF_PI</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">HALF_PI</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="../../../../constant-values.html#com.github.yellowstonegames.core.TrigTools.HALF_PI">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="PI2">
<h3>PI2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">PI2</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="../../../../constant-values.html#com.github.yellowstonegames.core.TrigTools.PI2">Constant Field Values</a></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor.detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>TrigTools</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">TrigTools</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="sin(double)">
<h3>sin</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">sin</span>&#8203;<span class="parameters">(double&nbsp;radians)</span></div>
<div class="block">A fairly-close approximation of <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#sin(double)" title="class or interface in java.lang" class="external-link"><code>Math.sin(double)</code></a> that can be significantly faster (between 8x and 80x
 faster sin() calls in benchmarking; if you have access to libGDX you should consider its sometimes-more-precise
 and sometimes-faster MathUtils.sin() method. Because this method doesn't rely on a
 lookup table, where libGDX's MathUtils does, applications that have a bottleneck on memory may perform better
 with this method than with MathUtils. Takes the same arguments Math.sin() does, so one angle in radians,
 which may technically be any double (but this will lose precision on fairly large doubles, such as those that are
 larger than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Long.html#MAX_VALUE" title="class or interface in java.lang" class="external-link"><code>Long.MAX_VALUE</code></a>, because those doubles themselves will lose precision at that scale). The
 difference between the result of this method and <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#sin(double)" title="class or interface in java.lang" class="external-link"><code>Math.sin(double)</code></a> should be under 0.0011 at
 all points between -pi and pi, with an average difference of about 0.0005; not all points have been checked for
 potentially higher errors, though.
 <br>
 The error for this double version is extremely close to the float version, <a href="#sin(float)"><code>sin(float)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 Unlike in previous versions of this method, the sign of the input doesn't affect performance here, at least not
 by a measurable amount.
 <br>
 The technique for sine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any double to the valid input range.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>radians</code> - an angle in radians as a double, often from 0 to pi * 2, though not required to be.</dd>
<dt>Returns:</dt>
<dd>the sine of the given angle, as a double between -1.0 and 1.0 (both inclusive)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="cos(double)">
<h3>cos</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">cos</span>&#8203;<span class="parameters">(double&nbsp;radians)</span></div>
<div class="block">A fairly-close approximation of <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#cos(double)" title="class or interface in java.lang" class="external-link"><code>Math.cos(double)</code></a> that can be significantly faster (between 8x and 80x
 faster cos() calls in benchmarking; if you have access to libGDX you should consider its sometimes-more-precise
 and sometimes-faster MathUtils.cos() method. Because this method doesn't rely on a
 lookup table, where libGDX's MathUtils does, applications that have a bottleneck on memory may perform better
 with this method than with MathUtils. Takes the same arguments Math.cos() does, so one angle in radians,
 which may technically be any double (but this will lose precision on fairly large doubles, such as those that are
 larger than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Long.html#MAX_VALUE" title="class or interface in java.lang" class="external-link"><code>Long.MAX_VALUE</code></a>, because those doubles themselves will lose precision at that scale). The
 difference between the result of this method and <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#cos(double)" title="class or interface in java.lang" class="external-link"><code>Math.cos(double)</code></a> should be under 0.0011 at
 all points between -pi and pi, with an average difference of about 0.0005; not all points have been checked for
 potentially higher errors, though.
 <br>
 The error for this double version is extremely close to the float version, <a href="#cos(float)"><code>cos(float)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 Unlike in previous versions of this method, the sign of the input doesn't affect performance here, at least not
 by a measurable amount.
 The technique for cosine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any double to the valid input range.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>radians</code> - an angle in radians as a double, often from 0 to pi * 2, though not required to be.</dd>
<dt>Returns:</dt>
<dd>the cosine of the given angle, as a double between -1.0 and 1.0 (both inclusive)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="sin(float)">
<h3>sin</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">sin</span>&#8203;<span class="parameters">(float&nbsp;radians)</span></div>
<div class="block">A fairly-close approximation of <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#sin(double)" title="class or interface in java.lang" class="external-link"><code>Math.sin(double)</code></a> that can be significantly faster (between 8x and 80x
 faster sin() calls in benchmarking, and both takes and returns floats; if you have access to libGDX you should
 consider its more-precise and sometimes-faster MathUtils.sin() method. Because this method doesn't rely on a
 lookup table, where libGDX's MathUtils does, applications that have a bottleneck on memory may perform better
 with this method than with MathUtils. Takes the same arguments Math.sin() does, so one angle in radians,
 which may technically be any float (but this will lose precision on fairly large floats, such as those that are
 larger than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Integer.html#MAX_VALUE" title="class or interface in java.lang" class="external-link"><code>Integer.MAX_VALUE</code></a>, because those floats themselves will lose precision at that scale). The
 difference between the result of this method and <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#sin(double)" title="class or interface in java.lang" class="external-link"><code>Math.sin(double)</code></a> should be under 0.0011 at
 all points between -pi and pi, with an average difference of about 0.0005; not all points have been checked for
 potentially higher errors, though.
 <br>
 The error for this float version is extremely close to the double version, <a href="#sin(double)"><code>sin(double)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 Unlike in previous versions of this method, the sign of the input doesn't affect performance here, at least not
 by a measurable amount.
 <br>
 The technique for sine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any float to the valid input range.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>radians</code> - an angle in radians as a float, often from 0 to pi * 2, though not required to be.</dd>
<dt>Returns:</dt>
<dd>the sine of the given angle, as a float between -1f and 1f (both inclusive)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="cos(float)">
<h3>cos</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">cos</span>&#8203;<span class="parameters">(float&nbsp;radians)</span></div>
<div class="block">A fairly-close approximation of <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#cos(double)" title="class or interface in java.lang" class="external-link"><code>Math.cos(double)</code></a> that can be significantly faster (between 8x and 80x
 faster cos() calls in benchmarking, and both takes and returns floats; if you have access to libGDX you should
 consider its more-precise and sometimes-faster MathUtils.cos() method. Because this method doesn't rely on a
 lookup table, where libGDX's MathUtils does, applications that have a bottleneck on memory may perform better
 with this method than with MathUtils. Takes the same arguments Math.cos() does, so one angle in radians,
 which may technically be any float (but this will lose precision on fairly large floats, such as those that are
 larger than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Integer.html#MAX_VALUE" title="class or interface in java.lang" class="external-link"><code>Integer.MAX_VALUE</code></a>, because those floats themselves will lose precision at that scale). The
 difference between the result of this method and <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#cos(double)" title="class or interface in java.lang" class="external-link"><code>Math.cos(double)</code></a> should be under 0.0011 at
 all points between -pi and pi, with an average difference of about 0.0005; not all points have been checked for
 potentially higher errors, though.
 <br>
 The error for this float version is extremely close to the double version, <a href="#cos(double)"><code>cos(double)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 Unlike in previous versions of this method, the sign of the input doesn't affect performance here, at least not
 by a measurable amount.
 <br>
 The technique for cosine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any float to the valid input range.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>radians</code> - an angle in radians as a float, often from 0 to pi * 2, though not required to be.</dd>
<dt>Returns:</dt>
<dd>the cosine of the given angle, as a float between -1f and 1f (both inclusive)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="sinDegrees(double)">
<h3>sinDegrees</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">sinDegrees</span>&#8203;<span class="parameters">(double&nbsp;degrees)</span></div>
<div class="block">A fairly-close approximation of <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#sin(double)" title="class or interface in java.lang" class="external-link"><code>Math.sin(double)</code></a> that can be significantly faster (between 8x and 80x
 faster sin() calls in benchmarking, and both takes and returns floats; if you have access to libGDX, you should
 consider its more-precise and sometimes-faster MathUtils.sinDeg() method. Because this method doesn't rely on a
 lookup table, where libGDX's MathUtils does, applications that have a bottleneck on memory may perform better
 with this method than with MathUtils. Takes one angle in degrees,
 which may technically be any float (but this will lose precision on fairly large floats, such as those that are
 larger than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Integer.html#MAX_VALUE" title="class or interface in java.lang" class="external-link"><code>Integer.MAX_VALUE</code></a>, because those floats themselves will lose precision at that scale). The
 difference between the result of this method and <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#sin(double)" title="class or interface in java.lang" class="external-link"><code>Math.sin(double)</code></a> should be under 0.0011 at
 all points between -360 and 360, with an average difference of about 0.0005; not all points have been checked for
 potentially higher errors, though.
 <br>
 The error for this float version is extremely close to the double version, <a href="#sin(double)"><code>sin(double)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 Unlike in previous versions of this method, the sign of the input doesn't affect performance here, at least not
 by a measurable amount.
 <br>
 The technique for sine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any float to the valid input range.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>degrees</code> - an angle in degrees as a float, often from 0 to 360, though not required to be.</dd>
<dt>Returns:</dt>
<dd>the sine of the given angle, as a float between -1f and 1f (both inclusive)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="cosDegrees(double)">
<h3>cosDegrees</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">cosDegrees</span>&#8203;<span class="parameters">(double&nbsp;degrees)</span></div>
<div class="block">A fairly-close approximation of <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#cos(double)" title="class or interface in java.lang" class="external-link"><code>Math.cos(double)</code></a> that can be significantly faster (between 8x and 80x
 faster cos() calls in benchmarking, and both takes and returns floats; if you have access to libGDX, you should
 consider its more-precise and sometimes-faster MathUtils.cosDeg() method. Because this method doesn't rely on a
 lookup table, where libGDX's MathUtils does, applications that have a bottleneck on memory may perform better
 with this method than with MathUtils. Takes one angle in degrees,
 which may technically be any float (but this will lose precision on fairly large floats, such as those that are
 larger than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Integer.html#MAX_VALUE" title="class or interface in java.lang" class="external-link"><code>Integer.MAX_VALUE</code></a>, because those floats themselves will lose precision at that scale). The
 difference between the result of this method and <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#cos(double)" title="class or interface in java.lang" class="external-link"><code>Math.cos(double)</code></a> should be under 0.0011 at
 all points between -360 and 360, with an average difference of about 0.0005; not all points have been checked for
 potentially higher errors, though.
 <br>
 The error for this float version is extremely close to the double version, <a href="#cos(double)"><code>cos(double)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 Unlike in previous versions of this method, the sign of the input doesn't affect performance here, at least not
 by a measurable amount.
 <br>
 The technique for cosine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any float to the valid input range.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>degrees</code> - an angle in degrees as a float, often from 0 to pi * 2, though not required to be.</dd>
<dt>Returns:</dt>
<dd>the cosine of the given angle, as a float between -1f and 1f (both inclusive)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="sinDegrees(float)">
<h3>sinDegrees</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">sinDegrees</span>&#8203;<span class="parameters">(float&nbsp;degrees)</span></div>
<div class="block">A fairly-close approximation of <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#sin(double)" title="class or interface in java.lang" class="external-link"><code>Math.sin(double)</code></a> that can be significantly faster (between 8x and 80x
 faster sin() calls in benchmarking, and both takes and returns floats; if you have access to libGDX, you should
 consider its more-precise and sometimes-faster MathUtils.sinDeg() method. Because this method doesn't rely on a
 lookup table, where libGDX's MathUtils does, applications that have a bottleneck on memory may perform better
 with this method than with MathUtils. Takes one angle in degrees,
 which may technically be any float (but this will lose precision on fairly large floats, such as those that are
 larger than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Integer.html#MAX_VALUE" title="class or interface in java.lang" class="external-link"><code>Integer.MAX_VALUE</code></a>, because those floats themselves will lose precision at that scale). The
 difference between the result of this method and <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#sin(double)" title="class or interface in java.lang" class="external-link"><code>Math.sin(double)</code></a> should be under 0.0011 at
 all points between -360 and 360, with an average difference of about 0.0005; not all points have been checked for
 potentially higher errors, though.
 <br>
 The error for this float version is extremely close to the double version, <a href="#sin(double)"><code>sin(double)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 Unlike in previous versions of this method, the sign of the input doesn't affect performance here, at least not
 by a measurable amount.
 <br>
 The technique for sine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any float to the valid input range.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>degrees</code> - an angle in degrees as a float, often from 0 to 360, though not required to be.</dd>
<dt>Returns:</dt>
<dd>the sine of the given angle, as a float between -1f and 1f (both inclusive)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="cosDegrees(float)">
<h3>cosDegrees</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">cosDegrees</span>&#8203;<span class="parameters">(float&nbsp;degrees)</span></div>
<div class="block">A fairly-close approximation of <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#cos(double)" title="class or interface in java.lang" class="external-link"><code>Math.cos(double)</code></a> that can be significantly faster (between 8x and 80x
 faster cos() calls in benchmarking, and both takes and returns floats; if you have access to libGDX, you should
 consider its more-precise and sometimes-faster MathUtils.cosDeg() method. Because this method doesn't rely on a
 lookup table, where libGDX's MathUtils does, applications that have a bottleneck on memory may perform better
 with this method than with MathUtils. Takes one angle in degrees,
 which may technically be any float (but this will lose precision on fairly large floats, such as those that are
 larger than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Integer.html#MAX_VALUE" title="class or interface in java.lang" class="external-link"><code>Integer.MAX_VALUE</code></a>, because those floats themselves will lose precision at that scale). The
 difference between the result of this method and <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#cos(double)" title="class or interface in java.lang" class="external-link"><code>Math.cos(double)</code></a> should be under 0.0011 at
 all points between -360 and 360, with an average difference of about 0.0005; not all points have been checked for
 potentially higher errors, though.
 <br>
 The error for this float version is extremely close to the double version, <a href="#cos(double)"><code>cos(double)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 Unlike in previous versions of this method, the sign of the input doesn't affect performance here, at least not
 by a measurable amount.
 <br>
 The technique for cosine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any float to the valid input range.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>degrees</code> - an angle in degrees as a float, often from 0 to pi * 2, though not required to be.</dd>
<dt>Returns:</dt>
<dd>the cosine of the given angle, as a float between -1f and 1f (both inclusive)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="sin_(double)">
<h3>sin_</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">sin_</span>&#8203;<span class="parameters">(double&nbsp;turns)</span></div>
<div class="block">A variation on <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#sin(double)" title="class or interface in java.lang" class="external-link"><code>Math.sin(double)</code></a> that takes its input as a fraction of a turn instead of in radians; one
 turn is equal to 360 degrees or two*PI radians. This can be useful as a building block for other measurements;
 to make a sine method that takes its input in grad (with 400 grad equal to 360 degrees), you would just divide
 the grad value by 400.0 (or multiply it by 0.0025) and pass it to this method. Similarly for binary degrees, also
 called brad (with 256 brad equal to 360 degrees), you would divide by 256.0 or multiply by 0.00390625 before
 passing that value here. The brad case is especially useful because you can use a byte for any brad values, and
 adding up those brad values will wrap correctly (256 brad goes back to 0) while keeping perfect precision for the
 results (you still divide by 256.0 when you pass the brad value to this method).
 <br>
 The error for this double version is extremely close to the float version, <a href="#sin_(float)"><code>sin_(float)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 The technique for sine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any double to the valid input range.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>turns</code> - an angle as a fraction of a turn as a double, with 0.5 here equivalent to PI radians in <a href="#cos(double)"><code>cos(double)</code></a></dd>
<dt>Returns:</dt>
<dd>the sine of the given angle, as a double between -1.0 and 1.0 (both inclusive)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="cos_(double)">
<h3>cos_</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">cos_</span>&#8203;<span class="parameters">(double&nbsp;turns)</span></div>
<div class="block">A variation on <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#cos(double)" title="class or interface in java.lang" class="external-link"><code>Math.cos(double)</code></a> that takes its input as a fraction of a turn instead of in radians; one
 turn is equal to 360 degrees or two*PI radians. This can be useful as a building block for other measurements;
 to make a cosine method that takes its input in grad (with 400 grad equal to 360 degrees), you would just divide
 the grad value by 400.0 (or multiply it by 0.0025) and pass it to this method. Similarly for binary degrees, also
 called brad (with 256 brad equal to 360 degrees), you would divide by 256.0 or multiply by 0.00390625 before
 passing that value here. The brad case is especially useful because you can use a byte for any brad values, and
 adding up those brad values will wrap correctly (256 brad goes back to 0) while keeping perfect precision for the
 results (you still divide by 256.0 when you pass the brad value to this method).
 <br>
 The error for this double version is extremely close to the float version, <a href="#cos_(float)"><code>cos_(float)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 The technique for cosine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any double to the valid input range.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>turns</code> - an angle as a fraction of a turn as a double, with 0.5 here equivalent to PI radians in <a href="#cos(double)"><code>cos(double)</code></a></dd>
<dt>Returns:</dt>
<dd>the cosine of the given angle, as a double between -1.0 and 1.0 (both inclusive)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="sin_(float)">
<h3>sin_</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">sin_</span>&#8203;<span class="parameters">(float&nbsp;turns)</span></div>
<div class="block">A variation on <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#sin(double)" title="class or interface in java.lang" class="external-link"><code>Math.sin(double)</code></a> that takes its input as a fraction of a turn instead of in radians (it
 also takes and returns a float); one turn is equal to 360 degrees or two*PI radians. This can be useful as a
 building block for other measurements; to make a sine method that takes its input in grad (with 400 grad equal to
 360 degrees), you would just divide the grad value by 400.0 (or multiply it by 0.0025) and pass it to this
 method. Similarly for binary degrees, also called brad (with 256 brad equal to 360 degrees), you would divide by
 256.0 or multiply by 0.00390625 before passing that value here. The brad case is especially useful because you
 can use a byte for any brad values, and adding up those brad values will wrap correctly (256 brad goes back to 0)
 while keeping perfect precision for the results (you still divide by 256.0 when you pass the brad value to this
 method).
 <br>
 The error for this float version is extremely close to the double version, <a href="#sin_(double)"><code>sin_(double)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 The technique for sine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any double to the valid input range.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>turns</code> - an angle as a fraction of a turn as a float, with 0.5 here equivalent to PI radians in <a href="#cos(double)"><code>cos(double)</code></a></dd>
<dt>Returns:</dt>
<dd>the sine of the given angle, as a float between -1.0 and 1.0 (both inclusive)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="cos_(float)">
<h3>cos_</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">cos_</span>&#8203;<span class="parameters">(float&nbsp;turns)</span></div>
<div class="block">A variation on <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#cos(double)" title="class or interface in java.lang" class="external-link"><code>Math.cos(double)</code></a> that takes its input as a fraction of a turn instead of in radians (it
 also takes and returns a float); one turn is equal to 360 degrees or two*PI radians. This can be useful as a
 building block for other measurements; to make a cosine method that takes its input in grad (with 400 grad equal
 to 360 degrees), you would just divide the grad value by 400.0 (or multiply it by 0.0025) and pass it to this
 method. Similarly for binary degrees, also called brad (with 256 brad equal to 360 degrees), you would divide by
 256.0 or multiply by 0.00390625 before passing that value here. The brad case is especially useful because you
 can use a byte for any brad values, and adding up those brad values will wrap correctly (256 brad goes back to 0)
 while keeping perfect precision for the results (you still divide by 256.0 when you pass the brad value to this
 method).
 <br>
 The error for this float version is extremely close to the float version, <a href="#cos_(double)"><code>cos_(double)</code></a>, so you should
 choose based on what type you have as input and/or want to return rather than on quality concerns. Coercion
 between float and double takes about as long as this method normally takes to run (or longer), so if you have
 floats you should usually use methods that take floats (or return floats, if assigning the result to a float),
 and likewise for doubles.
 <br>
 The technique for cosine approximation is mostly from
 <a href="https://web.archive.org/web/20080228213915/http://devmaster.net/forums/showthread.php?t=5784">this archived DevMaster thread</a>,
 with credit to "Nick". Changes have been made to accelerate wrapping from any double to the valid input range.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>turns</code> - an angle as a fraction of a turn as a float, with 0.5 here equivalent to PI radians in <a href="#cos(double)"><code>cos(double)</code></a></dd>
<dt>Returns:</dt>
<dd>the cosine of the given angle, as a float between -1.0 and 1.0 (both inclusive)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="atan(double)">
<h3>atan</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">atan</span>&#8203;<span class="parameters">(double&nbsp;i)</span></div>
<div class="block">Arc tangent approximation with very low error, using an algorithm from the 1955 research study
 "Approximations for Digital Computers," by RAND Corporation (this is sheet 9's algorithm, which is the
 second-fastest and second-least precise). This method is usually much faster than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#atan(double)" title="class or interface in java.lang" class="external-link"><code>Math.atan(double)</code></a>,
 but is somewhat less precise than Math's implementation.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>i</code> - an input to the inverse tangent function; any double is accepted</dd>
<dt>Returns:</dt>
<dd>an output from the inverse tangent function, from PI/-2.0 to PI/2.0 inclusive</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="atan(float)">
<h3>atan</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">atan</span>&#8203;<span class="parameters">(float&nbsp;i)</span></div>
<div class="block">Arc tangent approximation with very low error, using an algorithm from the 1955 research study
 "Approximations for Digital Computers," by RAND Corporation (this is sheet 9's algorithm, which is the
 second-fastest and second-least precise). This method is usually much faster than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#atan(double)" title="class or interface in java.lang" class="external-link"><code>Math.atan(double)</code></a>,
 but is somewhat less precise than Math's implementation.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>i</code> - an input to the inverse tangent function; any float is accepted</dd>
<dt>Returns:</dt>
<dd>an output from the inverse tangent function, from PI/-2.0 to PI/2.0 inclusive</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="atan2(double,double)">
<h3>atan2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">atan2</span>&#8203;<span class="parameters">(double&nbsp;y,
 double&nbsp;x)</span></div>
<div class="block">Close approximation of the frequently-used trigonometric method atan2, with higher precision than libGDX's atan2
 approximation. Maximum error is below 0.00009 radians.
 Takes y and x (in that unusual order) as doubles, and returns the angle from the origin to that point in radians.
 It is about 5 times faster than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#atan2(double,double)" title="class or interface in java.lang" class="external-link"><code>Math.atan2(double, double)</code></a> (roughly 12 ns instead of roughly 62 ns for
 Math, on Java 8 HotSpot). It is slightly faster than libGDX' MathUtils approximation of the same method;
 MathUtils seems to have worse average error, though.
 <br>
 Credit for this goes to the 1955 research study "Approximations for Digital Computers," by RAND Corporation. This
 is sheet 9's algorithm, which is the second-fastest and second-least precise. The algorithm on sheet 8 is faster,
 but only by a very small degree, and is considerably less precise. That study provides an <a href="#atan(double)"><code>atan(double)</code></a>
 method, and the small code to make that work as atan2() was worked out from Wikipedia.
 <br>
 See also <a href="#atan2_(double,double)"><code>atan2_(double, double)</code></a> if you don't want a mess converting to degrees or some other
 measurement, since that method returns an angle from 0f (equal to 0 degrees) to 1f (equal to 360 degrees). You
 can also use <a href="#atan2Degrees(double,double)"><code>atan2Degrees(double, double)</code></a> or <a href="#atan2Degrees360(double,double)"><code>atan2Degrees360(double, double)</code></a> to produce a
 result in degrees, either from -180 to 180 or 0 to 360.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>y</code> - y-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dd><code>x</code> - x-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dt>Returns:</dt>
<dd>the angle to the given point, in radians as a double; ranges from -PI to PI</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="atan2(float,float)">
<h3>atan2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">atan2</span>&#8203;<span class="parameters">(float&nbsp;y,
 float&nbsp;x)</span></div>
<div class="block">Close approximation of the frequently-used trigonometric method atan2, with higher precision than libGDX's atan2
 approximation. Maximum error is below 0.00009 radians.
 Takes y and x (in that unusual order) as floats, and returns the angle from the origin to that point in radians.
 It is about 5 times faster than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#atan2(double,double)" title="class or interface in java.lang" class="external-link"><code>Math.atan2(double, double)</code></a> (roughly 12 ns instead of roughly 62 ns for
 Math, on Java 8 HotSpot). It is slightly faster than libGDX' MathUtils approximation of the same method;
 MathUtils seems to have worse average error, though.
 <br>
 Credit for this goes to the 1955 research study "Approximations for Digital Computers," by RAND Corporation. This
 is sheet 9's algorithm, which is the second-fastest and second-least precise. The algorithm on sheet 8 is faster,
 but only by a very small degree, and is considerably less precise. That study provides an <a href="#atan(float)"><code>atan(float)</code></a>
 method, and the small code to make that work as atan2() was worked out from Wikipedia.
 <br>
 See also <a href="#atan2_(float,float)"><code>atan2_(float, float)</code></a> if you don't want a mess converting to degrees or some other measurement,
 since that method returns an angle from 0f (equal to 0 degrees) to 1f (equal to 360 degrees). You can also use
 <a href="#atan2Degrees(float,float)"><code>atan2Degrees(float, float)</code></a> or <a href="#atan2Degrees360(float,float)"><code>atan2Degrees360(float, float)</code></a> to produce a result in degrees,
 either from -180 to 180 or 0 to 360.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>y</code> - y-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dd><code>x</code> - x-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dt>Returns:</dt>
<dd>the angle to the given point, in radians as a float; ranges from -PI to PI</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="atan2_(double,double)">
<h3>atan2_</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">atan2_</span>&#8203;<span class="parameters">(double&nbsp;y,
 double&nbsp;x)</span></div>
<div class="block">Altered-range approximation of the frequently-used trigonometric method atan2, taking y and x positions as
 doubles and returning an angle measured in turns from 0.0 to 1.0 (inclusive), with one cycle over the range
 equivalent to 360 degrees or 2PI radians. You can multiply the angle by <code>6.2831855f</code> to change to radians,
 or by <code>360f</code> to change to degrees. Takes y and x (in that unusual order) as doubles. Will never return a
 negative number, which may help avoid costly floating-point modulus when you actually want a positive number.
 <br>
 Credit for this goes to the 1955 research study "Approximations for Digital Computers," by RAND Corporation. This
 is sheet 9's algorithm, which is the second-fastest and second-least precise. The algorithm on sheet 8 is faster,
 but only by a very small degree, and is considerably less precise. That study provides an <a href="#atan(float)"><code>atan(float)</code></a>
 method, and the small code to make that work as atan2_() was worked out from Wikipedia.
 <br>
 Note that <a href="#atan2(double,double)"><code>atan2(double, double)</code></a> returns an angle in radians and can return negative results, which may
 be fine for many tasks; these two methods are extremely close in implementation and speed. There are also
 <a href="#atan2Degrees(double,double)"><code>atan2Degrees(double, double)</code></a> and <a href="#atan2Degrees360(double,double)"><code>atan2Degrees360(double, double)</code></a>, which provide an angle in
 degrees, either from -180 to 180 or 0 to 360.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>y</code> - y-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dd><code>x</code> - x-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dt>Returns:</dt>
<dd>the angle to the given point, as a double from 0.0 to 1.0, inclusive</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="atan2_(float,float)">
<h3>atan2_</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">atan2_</span>&#8203;<span class="parameters">(float&nbsp;y,
 float&nbsp;x)</span></div>
<div class="block">Altered-range approximation of the frequently-used trigonometric method atan2, taking y and x positions as floats
 and returning an angle measured in turns from 0.0f to 1.0f, with one cycle over the range equivalent to 360
 degrees or 2PI radians. You can multiply the angle by <code>6.2831855f</code> to change to radians, or by <code>360f</code>
 to change to degrees. Takes y and x (in that unusual order) as floats. Will never return a negative number, which
 may help avoid costly floating-point modulus when you actually want a positive number.
 <br>
 Credit for this goes to the 1955 research study "Approximations for Digital Computers," by RAND Corporation. This
 is sheet 9's algorithm, which is the second-fastest and second-least precise. The algorithm on sheet 8 is faster,
 but only by a very small degree, and is considerably less precise. That study provides an <a href="#atan(float)"><code>atan(float)</code></a>
 method, and the small code to make that work as atan2_() was worked out from Wikipedia.
 <br>
 Note that <a href="#atan2(float,float)"><code>atan2(float, float)</code></a> returns an angle in radians and can return negative results, which may
 be fine for many tasks; these two methods are extremely close in implementation and speed. There are also
 <a href="#atan2Degrees(float,float)"><code>atan2Degrees(float, float)</code></a> and <a href="#atan2Degrees360(float,float)"><code>atan2Degrees360(float, float)</code></a>, which provide an angle in
 degrees, either from -180 to 180 or 0 to 360.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>y</code> - y-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dd><code>x</code> - x-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dt>Returns:</dt>
<dd>the angle to the given point, as a float from 0.0f to 1.0f, inclusive</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="atanDegrees(double)">
<h3>atanDegrees</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">atanDegrees</span>&#8203;<span class="parameters">(double&nbsp;i)</span></div>
<div class="block">Arc tangent approximation measured in degrees, using an algorithm from the 1955 research study
 "Approximations for Digital Computers," by RAND Corporation (this is sheet 9's algorithm, which is the
 second-fastest and second-least precise). This method is usually much faster than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#atan(double)" title="class or interface in java.lang" class="external-link"><code>Math.atan(double)</code></a>,
 but is somewhat less precise than Math's implementation. This implementation can return negative or positive
 results in degrees.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>i</code> - an input to the inverse tangent function; any double is accepted</dd>
<dt>Returns:</dt>
<dd>an output from the inverse tangent function in degrees, from -90 to 90 inclusive</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="atanDegrees(float)">
<h3>atanDegrees</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">atanDegrees</span>&#8203;<span class="parameters">(float&nbsp;i)</span></div>
<div class="block">Arc tangent approximation measured in degrees, using an algorithm from the 1955 research study
 "Approximations for Digital Computers," by RAND Corporation (this is sheet 9's algorithm, which is the
 second-fastest and second-least precise). This method is usually much faster than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#atan(double)" title="class or interface in java.lang" class="external-link"><code>Math.atan(double)</code></a>,
 but is somewhat less precise than Math's implementation. This implementation can return negative or positive
 results in degrees.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>i</code> - an input to the inverse tangent function; any float is accepted</dd>
<dt>Returns:</dt>
<dd>an output from the inverse tangent function, from -90 to 90 inclusive</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="atan2Degrees(double,double)">
<h3>atan2Degrees</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">atan2Degrees</span>&#8203;<span class="parameters">(double&nbsp;y,
 double&nbsp;x)</span></div>
<div class="block">Close approximation of the frequently-used trigonometric method atan2 measured in degrees, with higher precision
 than libGDX's atan2 approximation. The range for this is -180 to 180.
 Takes y and x (in that unusual order) as doubles, and returns the angle from the origin to that point in degrees.
 It is about 5 times faster than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#atan2(double,double)" title="class or interface in java.lang" class="external-link"><code>Math.atan2(double, double)</code></a> (roughly 12 ns instead of roughly 62 ns for
 Math, on Java 8 HotSpot). It is slightly faster than libGDX' MathUtils approximation of the same method;
 MathUtils seems to have worse average error, as well.
 <br>
 Credit for this goes to the 1955 research study "Approximations for Digital Computers," by RAND Corporation. This
 is sheet 9's algorithm, which is the second-fastest and second-least precise. The algorithm on sheet 8 is faster,
 but only by a very small degree, and is considerably less precise. That study provides an <a href="#atan(double)"><code>atan(double)</code></a>
 method, and the small code to make that work as atan2Degrees() was worked out from Wikipedia.
 <br>
 See also <a href="#atan2_(double,double)"><code>atan2_(double, double)</code></a> for a version that returns a measurement as a fraction of a turn, or
 <a href="#atan2(double,double)"><code>atan2(double, double)</code></a> for the typical radians. You
 can also use <a href="#atan2Degrees360(double,double)"><code>atan2Degrees360(double, double)</code></a> to produce a result in degrees from 0 to 360.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>y</code> - y-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dd><code>x</code> - x-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dt>Returns:</dt>
<dd>the angle to the given point, in radians as a double; ranges from -180 to 180</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="atan2Degrees(float,float)">
<h3>atan2Degrees</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">atan2Degrees</span>&#8203;<span class="parameters">(float&nbsp;y,
 float&nbsp;x)</span></div>
<div class="block">Close approximation of the frequently-used trigonometric method atan2 measured in degrees, with higher precision
 than libGDX's atan2 approximation. The range for this is -180 to 180.
 Takes y and x (in that unusual order) as floats, and returns the angle from the origin to that point in degrees.
 It is about 5 times faster than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#atan2(double,double)" title="class or interface in java.lang" class="external-link"><code>Math.atan2(double, double)</code></a> (roughly 12 ns instead of roughly 62 ns for
 Math, on Java 8 HotSpot). It is slightly faster than libGDX' MathUtils approximation of the same method;
 MathUtils seems to have worse average error, as well.
 <br>
 Credit for this goes to the 1955 research study "Approximations for Digital Computers," by RAND Corporation. This
 is sheet 9's algorithm, which is the second-fastest and second-least precise. The algorithm on sheet 8 is faster,
 but only by a very small degree, and is considerably less precise. That study provides an <a href="#atan(float)"><code>atan(float)</code></a>
 method, and the small code to make that work as atan2Degrees() was worked out from Wikipedia.
 <br>
 See also <a href="#atan2_(float,float)"><code>atan2_(float, float)</code></a> for a version that returns a measurement as a fraction of a turn, or
 <a href="#atan2(float,float)"><code>atan2(float, float)</code></a> for the typical radians. You
 can also use <a href="#atan2Degrees360(float,float)"><code>atan2Degrees360(float, float)</code></a> to produce a result in degrees from 0 to 360.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>y</code> - y-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dd><code>x</code> - x-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dt>Returns:</dt>
<dd>the angle to the given point, in radians as a float; ranges from -180 to 180</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="atan2Degrees360(double,double)">
<h3>atan2Degrees360</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">atan2Degrees360</span>&#8203;<span class="parameters">(double&nbsp;y,
 double&nbsp;x)</span></div>
<div class="block">Altered-range approximation of the frequently-used trigonometric method atan2, taking y and x positions as
 doubles and returning an angle measured in turns from 0.0 to 360.0 (inclusive), with one cycle over the range
 equivalent to 2PI radians or 1 turn. Takes y and x (in that unusual order) as doubles. Will never return a
 negative number, which may help avoid costly floating-point modulus when you actually want a positive number.
 <br>
 Credit for this goes to the 1955 research study "Approximations for Digital Computers," by RAND Corporation. This
 is sheet 9's algorithm, which is the second-fastest and second-least precise. The algorithm on sheet 8 is faster,
 but only by a very small degree, and is considerably less precise. That study provides an <a href="#atan(double)"><code>atan(double)</code></a>
 method, and the small code to make that work as atan2Degrees360() was worked out from Wikipedia.
 <br>
 See also <a href="#atan2_(double,double)"><code>atan2_(double, double)</code></a> for a version that returns a measurement as a fraction of a turn, or
 <a href="#atan2(double,double)"><code>atan2(double, double)</code></a> for the typical radians. You
 can also use <a href="#atan2Degrees(double,double)"><code>atan2Degrees(double, double)</code></a> to produce a result in degrees from -180 to 180.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>y</code> - y-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dd><code>x</code> - x-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dt>Returns:</dt>
<dd>the angle to the given point, as a double from 0.0 to 360.0, inclusive</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="atan2Degrees360(float,float)">
<h3>atan2Degrees360</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">atan2Degrees360</span>&#8203;<span class="parameters">(float&nbsp;y,
 float&nbsp;x)</span></div>
<div class="block">Altered-range approximation of the frequently-used trigonometric method atan2, taking y and x positions as
 floats and returning an angle measured in turns from 0.0 to 360.0 (inclusive), with one cycle over the range
 equivalent to 2PI radians or 1 turn. Takes y and x (in that unusual order) as floats. Will never return a
 negative number, which may help avoid costly floating-point modulus when you actually want a positive number.
 <br>
 Credit for this goes to the 1955 research study "Approximations for Digital Computers," by RAND Corporation. This
 is sheet 9's algorithm, which is the second-fastest and second-least precise. The algorithm on sheet 8 is faster,
 but only by a very small degree, and is considerably less precise. That study provides an <a href="#atan(float)"><code>atan(float)</code></a>
 method, and the small code to make that work as atan2Degrees360() was worked out from Wikipedia.
 <br>
 See also <a href="#atan2_(float,float)"><code>atan2_(float, float)</code></a> for a version that returns a measurement as a fraction of a turn, or
 <a href="#atan2(float,float)"><code>atan2(float, float)</code></a> for the typical radians. You
 can also use <a href="#atan2Degrees(float,float)"><code>atan2Degrees(float, float)</code></a> to produce a result in degrees from -180 to 180.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>y</code> - y-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dd><code>x</code> - x-component of the point to find the angle towards; note the parameter order is unusual by convention</dd>
<dt>Returns:</dt>
<dd>the angle to the given point, as a float from 0.0 to 360.0, inclusive</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="asin(float)">
<h3>asin</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">asin</span>&#8203;<span class="parameters">(float&nbsp;x)</span></div>
<div class="block">Arc sine approximation with very low error, using an algorithm from the 1955 research study
 "Approximations for Digital Computers," by RAND Corporation (this is sheet 35's algorithm, which is the fastest
 and least precise). This method is usually much faster than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#asin(double)" title="class or interface in java.lang" class="external-link"><code>Math.asin(double)</code></a>, but is somewhat less
 precise than Math's implementation. It is currently the same as libGDX's approximation in their MathUtils.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - an input to the inverse sine function, from -1 to 1 inclusive</dd>
<dt>Returns:</dt>
<dd>an output from the inverse sine function, from PI/-2.0 to PI/2.0 inclusive.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="acos(float)">
<h3>acos</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">acos</span>&#8203;<span class="parameters">(float&nbsp;x)</span></div>
<div class="block">Arc cosine approximation with very low error, using an algorithm from the 1955 research study
 "Approximations for Digital Computers," by RAND Corporation (this is sheet 35's algorithm, which is the fastest
 and least precise). This method is usually much faster than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#acos(double)" title="class or interface in java.lang" class="external-link"><code>Math.acos(double)</code></a>, but is somewhat less
 precise than Math's implementation. It is currently the same as libGDX's approximation in their MathUtils.
 <br>
 Accuracy: absolute error 0.000028450, relative error -0.000000011, max error 0.000067548 .</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - an input to the inverse cosine function, from -1 to 1 inclusive</dd>
<dt>Returns:</dt>
<dd>an output from the inverse cosine function, from 0 to PI inclusive.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="asin(double)">
<h3>asin</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">asin</span>&#8203;<span class="parameters">(double&nbsp;x)</span></div>
<div class="block">Arc sine approximation with very low error, using an algorithm from the 1955 research study
 "Approximations for Digital Computers," by RAND Corporation (this is sheet 35's algorithm, which is the fastest
 and least precise). This method is usually much faster than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#asin(double)" title="class or interface in java.lang" class="external-link"><code>Math.asin(double)</code></a>, but is somewhat less
 precise than Math's implementation. It is currently the same as libGDX's approximation in their MathUtils, except
 that this takes a double and returns a double.
 <br>
 Accuracy: absolute error 0.000028447, relative error -0.000000033, max error 0.000067592 .</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - an input to the inverse sine function, from -1 to 1 inclusive</dd>
<dt>Returns:</dt>
<dd>an output from the inverse sine function, from PI/-2.0 to PI/2.0 inclusive.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="acos(double)">
<h3>acos</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">acos</span>&#8203;<span class="parameters">(double&nbsp;x)</span></div>
<div class="block">Arc cosine approximation with very low error, using an algorithm from the 1955 research study
 "Approximations for Digital Computers," by RAND Corporation (this is sheet 35's algorithm, which is the fastest
 and least precise). This method is usually much faster than <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Math.html#acos(double)" title="class or interface in java.lang" class="external-link"><code>Math.acos(double)</code></a>, but is somewhat less
 precise than Math's implementation. It is currently the same as libGDX's approximation in their MathUtils, except
 that this takes a double and returns a double.
 <br>
 Accuracy: absolute error 0.000028450, relative error -0.000000011, max error 0.000067548 .</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - an input to the inverse cosine function, from -1 to 1 inclusive</dd>
<dt>Returns:</dt>
<dd>an output from the inverse cosine function, from 0 to PI inclusive.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="asin_(double)">
<h3>asin_</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">asin_</span>&#8203;<span class="parameters">(double&nbsp;x)</span></div>
<div class="block">Inverse sine function (arcsine) but with output measured in turns instead of radians. Possible results for this
 range from 0.75 (inclusive) to 1.0 (exclusive), and continuing past that to 0.0 (inclusive) to 0.25 (inclusive).
 <br>
 This method is extremely similar to the non-turn approximation, but it never returns a negative result.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - a double from -1.0 to 1.0 (both inclusive), usually the output of sin_() or cos_()</dd>
<dt>Returns:</dt>
<dd>one of the values that would produce <code>n</code> if it were passed to <a href="#sin_(double)"><code>sin_(double)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="acos_(double)">
<h3>acos_</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">acos_</span>&#8203;<span class="parameters">(double&nbsp;x)</span></div>
<div class="block">Inverse cosine function (arccos) but with output measured in turns instead of radians. Possible results for this
 range from 0.0 (inclusive) to 0.5 (inclusive).
 <br>
 This method is extremely similar to the non-turn approximation.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - a double from -1.0 to 1.0 (both inclusive), usually the output of sin_() or cos_()</dd>
<dt>Returns:</dt>
<dd>one of the values that would produce <code>n</code> if it were passed to <a href="#cos_(double)"><code>cos_(double)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="asin_(float)">
<h3>asin_</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">asin_</span>&#8203;<span class="parameters">(float&nbsp;x)</span></div>
<div class="block">Inverse sine function (arcsine) but with output measured in turns instead of radians. Possible results for this
 range from 0.75f (inclusive) to 1.0f (exclusive), and continuing past that to 0.0f (inclusive) to 0.25f
 (inclusive).
 <br>
 This method is extremely similar to the non-turn approximation, but it never returns a negative result.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - a float from -1.0f to 1.0f (both inclusive), usually the output of sin_() or cos_()</dd>
<dt>Returns:</dt>
<dd>one of the values that would produce <code>n</code> if it were passed to <a href="#sin_(float)"><code>sin_(float)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="acos_(float)">
<h3>acos_</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">acos_</span>&#8203;<span class="parameters">(float&nbsp;x)</span></div>
<div class="block">Inverse cosine function (arccos) but with output measured in turns instead of radians. Possible results for this
 range from 0.0f (inclusive) to 0.5f (inclusive).
 <br>
 This method is extremely similar to the non-turn approximation.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - a float from -1.0f to 1.0f (both inclusive), usually the output of sin_() or cos_()</dd>
<dt>Returns:</dt>
<dd>one of the values that would produce <code>n</code> if it were passed to <a href="#cos_(float)"><code>cos_(float)</code></a></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>
