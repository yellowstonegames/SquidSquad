/*
 * Copyright (c) 2020-2024 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.github.yellowstonegames.seek.technique;

import com.github.tommyettinger.gand.GradientGrid;
import com.github.yellowstonegames.grid.Coord;
import com.github.yellowstonegames.grid.CoordFloatOrderedMap;

import java.util.Collection;

/**
 * Static utilities for use in AOE and anything else that might need CoordFloatOrderedMaps.
 */
public class AreaUtils {
    /**
     * This takes a 2D boolean array and returns a CoordFloatOrderedMap, but will only use the value
     * 1.0, and only for positions in map that have as their boolean element true.
     * @param map width by height
     * @return a CoordFloatOrderedMap, but the only value used is 1.0
     */
    public static CoordFloatOrderedMap arrayToMap(boolean[][] map)
    {
        CoordFloatOrderedMap ret = new CoordFloatOrderedMap();
        for(int i = 0; i < map.length; i++)
        {
            for(int j = 0; j < map[i].length; j++)
            {
                if(map[i][j])
                    ret.put(Coord.get(i, j), 1f);
            }
        }
        return ret;
    }

    /**
     * This takes a Collection of Coord, such as a Region, and returns a CoordFloatOrderedMap, but will only use the
     * value 1.0, and only for positions in coll.
     * @param coll any Collection of Coord, such as a Region
     * @return a CoordFloatOrderedMap, but the only value used is 1.0
     */
    public static CoordFloatOrderedMap collectionToMap(Collection<Coord> coll)
    {
        CoordFloatOrderedMap ret = new CoordFloatOrderedMap(coll.size());
        for(Coord c : coll) {
            ret.put(c, 1f);
        }
        return ret;
    }

    /**
     * This takes a 2D float array called map and returns a CoordFloatOrderedMap, and will have a key
     * for every position in map that is greater than 0.0, with values equal to those in map.
     * @param map width by height, commonly generated by FOV methods
     * @return a CoordFloatOrderedMap, with values all greater than 0.0
     */
    public static CoordFloatOrderedMap arrayToMap(float[][] map)
    {
        CoordFloatOrderedMap ret = new CoordFloatOrderedMap();
        for(int i = 0; i < map.length; i++)
        {
            for(int j = 0; j < map[i].length; j++)
            {
                if(map[i][j] > 0.0)
                    ret.put(Coord.get(i, j), map[i][j]);
            }
        }
        return ret;
    }

    /**
     * This takes a 2D float array and returns a CoordFloatOrderedMap, but will only use the value
     * 1.0, and only does this if the passed float[][] has a value at that position that is greater than cutoff.
     * For example, a cutoff of 0.3 will make all elements in the 2D array that are 0.3 or less be ignored and not put
     * into the map, but all elements that are greater than 0.3 will be placed in as 1.0.
     * @param map width by height, commonly generated by FOV methods
     * @param cutoff any elements greater than this will be 1.0 in the return, anything else will be ignored
     * @return a CoordFloatOrderedMap, but the only value used is 1.0
     */
    public static CoordFloatOrderedMap arrayToMap(float[][] map, float cutoff)
    {
        CoordFloatOrderedMap ret = new CoordFloatOrderedMap();
        for(int i = 0; i < map.length; i++)
        {
            for(int j = 0; j < map[i].length; j++)
            {
                if(map[i][j] > cutoff)
                    ret.put(Coord.get(i, j), 1f);
            }
        }
        return ret;
    }

    /**
     * This takes a DijkstraMap that has already completed a scan() and returns a CoordFloatOrderedMap, and will have a
     * key for every position that was reached in the DijkstraMap, with 1.0 as the only value.
     * @param map a float[][] returned by a DijkstraMap running its scan()
     * @return a CoordFloatOrderedMap, with values of 1.0 only
     */
    public static CoordFloatOrderedMap dijkstraToHashMap(float[][] map)
    {
        CoordFloatOrderedMap ret = new CoordFloatOrderedMap();
        for(int i = 0; i < map.length; i++)
        {
            for(int j = 0; j < map[i].length; j++)
            {
                if(map[i][j] < GradientGrid.WALL)
                    ret.put(Coord.get(i, j), 1f);
            }
        }
        return ret;
    }

    /**
     * Checks that the given end Coord can be targeted from the given origin Coord given the directional targeting
     * rules specified by limit. If any of the arguments are null, returns true (it assumes that any limits are not
     * valid and don't restrict anything). The following AimLimit enum values for limit have the following meanings:
     *
     * <ul>
     *     <li>AimLimit.FREE makes no restrictions; it is equivalent here to passing null for limit.</li>
     *     <li>AimLimit.EIGHT_WAY will only consider Points to be valid targets
     *     if they are along a straight line with an angle that is a multiple of 45 degrees, relative to the positive x
     *     axis. Essentially, this limits the points to those a queen could move to in chess.</li>
     *     <li>AimLimit.ORTHOGONAL will cause the AOE to only consider Points to be valid targets if
     *     they are along a straight line with an angle that is a multiple of 90 degrees, relative to the positive x
     *     axis. Essentially, this limits the points to those a rook could move to in chess.</li>
     *     <li>AimLimit.DIAGONAL will cause the AOE to only consider Points to be valid targets if they are along a
     *     straight line with an angle that is 45 degrees greater than a multiple of 90 degrees, relative to the
     *     positive x axis. Essentially, this limits the points to those a bishop could move to in chess.</li>
     * </ul>
     *
     * @param limit an AimLimit enum that restricts valid points unless it is AimLimit.FREE or null
     * @param origin where the user is
     * @param end where the point we want to verify is
     * @return true if the point is a valid target or if the limits are invalid (non-restricting), false otherwise
     */
    public static boolean verifyLimit(AimLimit limit, Coord origin, Coord end)
    {
        if (limit != null && origin != null && end != null) {
            if(limit == AimLimit.FREE) return true;
            if(Math.abs(end.x - origin.x) == Math.abs(end.y - origin.y)){
                if(limit == AimLimit.EIGHT_WAY || limit == AimLimit.DIAGONAL) return true;
            }
            if(end.x == origin.x || end.y == origin.y) {
                if(limit == AimLimit.EIGHT_WAY || limit == AimLimit.ORTHOGONAL) return true;
            }
            return false; // limits are valid and their requirements are not met
        }
        return true; // limits are invalid; not restricted
    }

    /**
     * Checks that the given end Coord can be targeted from the given origin Coord given the complete targeting rules
     * specified by reach. If any of the arguments are null, returns true (it assumes that any limits are not
     * valid and don't restrict anything). If reach.limit is null, it treats it as equivalent to {@link AimLimit#FREE}.
     * Otherwise, it uses the metric, minDistance, and maxDistance from reach to calculate if end is target-able from
     * origin assuming an unobstructed playing field.
     *
     * @param reach a Reach object that, if non-null, gives limits for how targeting can proceed.
     * @param origin where the user is
     * @param end where the point we want to verify is
     * @return true if the point is a valid target or if the limits are invalid (non-restricting), false otherwise
     */
    public static boolean verifyReach(Reach reach, Coord origin, Coord end)
    {
        if(reach == null) // limits are invalid; not restricted
            return true;
        AimLimit limit = reach.limit;
        if(limit == null) limit = AimLimit.FREE;
        if (origin != null && end != null) {
            if(limit == AimLimit.FREE
                    || (Math.abs(end.x - origin.x) == Math.abs(end.y - origin.y)
                    && (limit == AimLimit.EIGHT_WAY || limit == AimLimit.DIAGONAL))
                    || ((end.x == origin.x || end.y == origin.y)
                    && (limit == AimLimit.EIGHT_WAY || limit == AimLimit.ORTHOGONAL)))
                return reach.metric.inRange(origin.x, origin.y, end.x, end.y,
                        reach.minDistance, reach.maxDistance);
            return false; // limits are valid and their requirements are not met
        }
        return true; // limits are invalid; not restricted
    }
}
