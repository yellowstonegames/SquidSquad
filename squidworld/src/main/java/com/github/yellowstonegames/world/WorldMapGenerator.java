/*
 * Copyright (c) 2022 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.github.yellowstonegames.world;

import com.github.tommyettinger.ds.IntList;
import com.github.tommyettinger.random.MizuchiRandom;
import com.github.tommyettinger.digital.ArrayTools;
import com.github.tommyettinger.digital.TrigTools;
import com.github.tommyettinger.random.MizuchiRandom;
import com.github.yellowstonegames.grid.Coord;
import com.github.yellowstonegames.grid.Noise;
import com.github.yellowstonegames.grid.Region;

/**
 * Can be used to generate world maps with a wide variety of data, starting with height, temperature and moisture.
 * To generate maps, this uses two {@code long} variables for its state, and if you use the same kind of {@link Noise}
 * configuration with the same state, you will get the same world as a result. Calling
 * {@link #generate(float, float, long, long)} also allows setting the land modifier and heat modifier to make worlds
 * that have more or less ocean vs. land and/or ice vs. desert.
 * <br>
 * There's lots of implementations here for different usage. The maps this produces with {@link StretchWorldMap} are
 * valid for stretching around spheres, while the maps from {@link TilingWorldMap} are for toroidal world projections
 * and will wrap from edge to opposite edge seamlessly thanks to
 * <a href="https://www.gamedev.net/blog/33/entry-2138456-seamless-noise/">a technique from the Accidental Noise
 * Library</a> that involves getting a 2D slice of 4D continuous noise, such as Simplex. Because of how continuous noise
 * works, this also allows extremely high zoom levels for all types of map as long as certain parameters are within
 * reason. Other world maps produce more conventional shapes; {@link GlobeMap} and {@link RotatingGlobeMap} make a
 * view of a marble-like world from space, and others make more unconventional shapes, like {@link EllipticalWorldMap},
 * which forms a 2:1 ellipse shape that accurately keeps sizes but not relative shapes, {@link RoundSideWorldMap}, which
 * forms a pill-shape, and {@link HyperellipticalWorldMap}, which takes parameters so it can fit
 * any shape between a circle or ellipse and a rectangle (the default is a slightly squared-off ellipse). You can access
 * the height map with the {@link #heightData} field, the heat map with the {@link #heatData} field, the moisture map
 * with the {@link #moistureData} field, and a special map that stores ints representing the codes for various ranges of
 * elevation (0 to 8 inclusive, with 0 the deepest ocean and 8 the highest mountains) with {@link #heightCodeData}. The
 * last map should be noted as being the simplest way to find what is land and what is water; any height code 4 or
 * greater is land, and any height code 3 or less is water.
 * <br>
 * This interacts closely with {@link BiomeMapper}, and BiomeMapper can't create a map of what types of ecosystem are
 * present without first having a world generated by a WorldMapGenerator.
 */
public abstract class WorldMapGenerator {

    public final int width, height;
    public long seedA;
    public long seedB;
    public long cacheA;
    public long cacheB;
    public MizuchiRandom rng;
    public final float[][] heightData, heatData, moistureData;
    public final Region landData;
    public final int[][] heightCodeData;
    public float landModifier = -1f, heatModifier = 1f,
            minHeight = Float.POSITIVE_INFINITY, maxHeight = Float.NEGATIVE_INFINITY,
            minHeightActual = Float.POSITIVE_INFINITY, maxHeightActual = Float.NEGATIVE_INFINITY,
            minHeat = Float.POSITIVE_INFINITY, maxHeat = Float.NEGATIVE_INFINITY,
            minWet = Float.POSITIVE_INFINITY, maxWet = Float.NEGATIVE_INFINITY;
    protected float centerLongitude;

    public int zoom, startX, startY, usedWidth, usedHeight;
    protected IntList startCacheX = new IntList(8), startCacheY = new IntList(8);
    protected int zoomStartX, zoomStartY;

    /**
     * A Noise that has a higher frequency than that class defaults to, which is useful for maps here. With the
     * default Noise frequency of 1f/32f, the maps this produces are giant blurs.
     * <br>
     * Even though this is a Noise and so technically can be edited, that seems to have issues when there's more
     * than one WorldMapGenerator that uses this field. So you can feel free to use this as a Noise when
     * generators need one, but don't change it too much, if at all.
     */
    public static final Noise DEFAULT_NOISE = new Noise(0x1337CAFE, 1f, Noise.HONEY_FRACTAL, 1);

    /**
     * Used to implement most of the copy constructor for subclasses; this cannot copy Noise implementations and leaves
     * that up to the subclass, but will copy all non-static fields defined in WorldMapGenerator from other.
     * @param other a WorldMapGenerator (subclass) to copy fields from
     */
    protected WorldMapGenerator(WorldMapGenerator other) {
        width = other.width;
        height = other.height;
        usedWidth = other.usedWidth;
        usedHeight = other.usedHeight;
        landModifier = other.landModifier;
        heatModifier = other.heatModifier;
        minHeat = other.minHeat;
        maxHeat = other.maxHeat;
        minHeight = other.minHeight;
        maxHeight = other.maxHeight;
        minHeightActual = other.minHeightActual;
        maxHeightActual = other.maxHeightActual;
        minWet = other.minWet;
        maxWet = other.maxWet;
        centerLongitude = other.centerLongitude;
        zoom = other.zoom;
        startX = other.startX;
        startY = other.startY;
        startCacheX.addAll(other.startCacheX);
        startCacheY.addAll(other.startCacheY);
        zoomStartX = other.zoomStartX;
        zoomStartY = other.zoomStartY;
        seedA = other.seedA;
        seedB = other.seedB;
        cacheA = other.cacheA;
        cacheB = other.cacheB;
        rng = other.rng.copy();
        heightData = ArrayTools.copy(other.heightData);
        heatData = ArrayTools.copy(other.heatData);
        moistureData = ArrayTools.copy(other.moistureData);
        landData = other.landData.copy();
        heightCodeData = ArrayTools.copy(other.heightCodeData);
    }

    /**
     * Gets the longitude line the map is centered on, which should usually be between 0 and 2 * PI.
     * @return the longitude line the map is centered on, in radians from 0 to 2 * PI
     */
    public float getCenterLongitude() {
        return centerLongitude;
    }

    /**
     * Sets the center longitude line to a longitude measured in radians, from 0 to 2 * PI. Positive arguments will be
     * corrected with modulo, but negative ones may not always act as expected, and are strongly discouraged.
     * @param centerLongitude the longitude to center the map projection on, from 0 to 2 * PI (can be any non-negative float).
     */
    public void setCenterLongitude(float centerLongitude) {
        this.centerLongitude = centerLongitude % 6.283185307179586f;
    }

    public static final float
            deepWaterLower = -1f, deepWaterUpper = -0.7f,        // 0
            mediumWaterLower = -0.7f, mediumWaterUpper = -0.3f,    // 1
            shallowWaterLower = -0.3f, shallowWaterUpper = -0.1f,  // 2
            coastalWaterLower = -0.1f, coastalWaterUpper = 0.02f,   // 3
            sandLower = 0.02f, sandUpper = 0.12f,                   // 4
            grassLower = 0.12f, grassUpper = 0.35f,                // 5
            forestLower = 0.35f, forestUpper = 0.6f,               // 6
            rockLower = 0.6f, rockUpper = 0.8f,                    // 7
            snowLower = 0.8f, snowUpper = 1f;                    // 8

    protected static float removeExcess(float radians)
    {
        radians *= 0.6366197723675814f;
        final int floor = (radians >= 0f ? (int) radians : (int) radians - 1);
        return (radians - (floor & -2) - ((floor & 1) << 1)) * TrigTools.PI;
    }
    /**
     * Constructs a WorldMapGenerator (this class is abstract, so you should typically call this from a subclass or as
     * part of an anonymous class that implements {@link #regenerate(int, int, int, int, float, float, long, long)}).
     * Always makes a 256x256 map. If you were using {@link WorldMapGenerator#WorldMapGenerator(long, int, int)}, then
     * this would be the same as passing the parameters {@code 0x1337BABE1337D00DL, 256, 256}.
     */
    protected WorldMapGenerator()
    {
        this(0x1337BABE1337D00DL, 256, 256);
    }
    /**
     * Constructs a WorldMapGenerator (this class is abstract, so you should typically call this from a subclass or as
     * part of an anonymous class that implements {@link #regenerate(int, int, int, int, float, float, long, long)}).
     * Takes only the width/height of the map. The initial seed is set to the same large long
     * every time, and it's likely that you would set the seed when you call {@link #generate(long, long)}. The width and
     * height of the map cannot be changed after the fact, but you can zoom in.
     *
     * @param mapWidth the width of the map(s) to generate; cannot be changed later
     * @param mapHeight the height of the map(s) to generate; cannot be changed later
     */
    protected WorldMapGenerator(int mapWidth, int mapHeight)
    {
        this(0x1337BABE1337D00DL, mapWidth, mapHeight);
    }
    /**
     * Constructs a WorldMapGenerator (this class is abstract, so you should typically call this from a subclass or as
     * part of an anonymous class that implements {@link #regenerate(int, int, int, int, float, float, long, long)}).
     * Takes an initial seed and the width/height of the map. The {@code initialSeed}
     * parameter may or may not be used, since you can specify the seed to use when you call {@link #generate(long, long)}.
     * The width and height of the map cannot be changed after the fact, but you can zoom in.
     *
     * @param initialSeed the seed for the MizuchiRandom this uses; this may also be set per-call to generate
     * @param mapWidth the width of the map(s) to generate; cannot be changed later
     * @param mapHeight the height of the map(s) to generate; cannot be changed later
     */
    protected WorldMapGenerator(long initialSeed, int mapWidth, int mapHeight)
    {
        width = mapWidth;
        height = mapHeight;
        usedWidth = width;
        usedHeight = height;
        seedA = initialSeed;
        seedB = initialSeed + 0xC6BC279692B5C323L | 1L;
        cacheA = ~seedA;
        cacheB = ~seedB;
        rng = new MizuchiRandom(seedA, seedB);
        heightData = new float[width][height];
        heatData = new float[width][height];
        moistureData = new float[width][height];
        landData = new Region(width, height);
        heightCodeData = new int[width][height];

//        riverData = new Region(width, height);
//        lakeData = new Region(width, height);
//        partialRiverData = new Region(width, height);
//        partialLakeData = new Region(width, height);
//        workingData = new Region(width, height);
    }

    /**
     * Generates a world using a random RNG state and all parameters randomized.
     * The worlds this produces will always have width and height as specified in the constructor (default 256x256).
     * You can call {@link #zoomIn(int, int, int)} to float the resolution and center on the specified area, but the width
     * and height of the 2D arrays this changed, such as {@link #heightData} and {@link #moistureData} will be the same.
     */
    public void generate()
    {
        generate(rng.nextLong(), rng.nextLong() | 1L);
    }

    /**
     * Generates a world using the specified RNG state as a long. Other parameters will be randomized, using the same
     * RNG state to start with.
     * The worlds this produces will always have width and height as specified in the constructor (default 256x256).
     * You can call {@link #zoomIn(int, int, int)} to float the resolution and center on the specified area, but the width
     * and height of the 2D arrays this changed, such as {@link #heightData} and {@link #moistureData} will be the same.
     * @param stateA the first part of state to give this generator's RNG; if the whole state is the same as the last call, this will reuse data
     * @param stateB the second part of state to give this generator's RNG; if the whole state is the same as the last call, this will reuse data
     */
    public void generate(long stateA, long stateB) {
        generate(-1f, -1f, stateA, stateB | 1L);
    }

    /**
     * Generates a world using the specified RNG state as a long, with specific land and heat modifiers that affect
     * the land-water ratio and the average temperature, respectively.
     * The worlds this produces will always have width and height as specified in the constructor (default 256x256).
     * You can call {@link #zoomIn(int, int, int)} to float the resolution and center on the specified area, but the width
     * and height of the 2D arrays this changed, such as {@link #heightData} and {@link #moistureData} will be the same.
     * @param landMod 1f is Earth-like, less than 1 is more-water, more than 1 is more-land; a random value will be used if this is negative
     * @param heatMod 1.125f is Earth-like, less than 1 is cooler, more than 1 is hotter; a random value will be used if this is negative
     * @param stateA the first part of state to give this generator's RNG; if the whole state is the same as the last call, this will reuse data
     * @param stateB the second part of state to give this generator's RNG; if the whole state is the same as the last call, this will reuse data
     */
    public void generate(float landMod, float heatMod, long stateA, long stateB)
    {
        if(cacheA != stateA || cacheB != (stateB | 1L) ||
                landMod != landModifier || heatMod != heatModifier)
        {
            seedA = stateA;
            seedB = stateB | 1L;
            zoom = 0;
            startCacheX.clear();
            startCacheY.clear();
            startCacheX.add(0);
            startCacheY.add(0);
            zoomStartX = width >> 1;
            zoomStartY = height >> 1;

        }
        //System.out.printf("generate, zoomStartX: %d, zoomStartY: %d\n", zoomStartX, zoomStartY);

        regenerate(startX = (zoomStartX >> zoom) - (width >> 1 + zoom), startY = (zoomStartY >> zoom) - (height >> 1 + zoom),
                //startCacheX.peek(), startCacheY.peek(),
                usedWidth = (width >> zoom), usedHeight = (height >> zoom), landMod, heatMod, seedA, seedB);
    }

    /**
     * Halves the resolution of the map and floats the area it covers; the 2D arrays this uses keep their sizes. This
     * version of zoomOut always zooms out from the center of the currently used area.
     * <br>
     * Only has an effect if you have previously zoomed in using {@link #zoomIn(int, int, int)} or its overload.
     */
    public void zoomOut()
    {
        zoomOut(1, width >> 1, height >> 1);
    }
    /**
     * Halves the resolution of the map and floats the area it covers repeatedly, halving {@code zoomAmount} times; the
     * 2D arrays this uses keep their sizes. This version of zoomOut allows you to specify where the zoom should be
     * centered, using the current coordinates (if the map size is 256x256, then coordinates should be between 0 and
     * 255, and will refer to the currently used area and not necessarily the full world size).
     * <br>
     * Only has an effect if you have previously zoomed in using {@link #zoomIn(int, int, int)} or its overload.
     * @param zoomCenterX the center X position to zoom out from; if too close to an edge, this will stop moving before it would extend past an edge
     * @param zoomCenterY the center Y position to zoom out from; if too close to an edge, this will stop moving before it would extend past an edge
     */
    public void zoomOut(int zoomAmount, int zoomCenterX, int zoomCenterY)
    {
        zoomAmount = Math.min(zoom, zoomAmount);
        if(zoomAmount == 0) return;
        if(zoomAmount < 0) {
            zoomIn(-zoomAmount, zoomCenterX, zoomCenterY);
            return;
        }
        if(zoom > 0)
        {
            if(cacheA != seedA || cacheB != seedB)
            {
                generate(rng.nextLong(), rng.nextLong() | 1L);
            }
            zoomStartX = Math.min(Math.max(
                    (zoomStartX + (zoomCenterX - (width >> 1))) >> zoomAmount,
                    width >> 1), (width << zoom - zoomAmount) - (width >> 1));
            zoomStartY = Math.min(Math.max(
                    (zoomStartY + (zoomCenterY - (height >> 1))) >> zoomAmount,
                    height >> 1), (height << zoom - zoomAmount) - (height >> 1));
//            System.out.printf("zoomOut, zoomStartX: %d, zoomStartY: %d\n", zoomStartX, zoomStartY);
            zoom -= zoomAmount;
            startCacheX.pop();
            startCacheY.pop();
            startCacheX.add(Math.min(Math.max(startCacheX.pop() + (zoomCenterX >> zoom + 1) - (width >> zoom + 2),
                    0), width - (width >> zoom)));
            startCacheY.add(Math.min(Math.max(startCacheY.pop() + (zoomCenterY >> zoom + 1) - (height >> zoom + 2),
                    0), height - (height >> zoom)));
//            zoomStartX = Math.min(Math.max((zoomStartX >> 1) + (zoomCenterX >> zoom + 1) - (width >> zoom + 2),
//                    0), width - (width >> zoom));
//            zoomStartY = Math.min(Math.max((zoomStartY >> 1) + (zoomCenterY >> zoom + 1) - (height >> zoom + 2),
//                    0), height - (height >> zoom));
            regenerate(startX = (zoomStartX >> zoom) - (width >> zoom + 1), startY = (zoomStartY >> zoom) - (height >> zoom + 1),
                    //startCacheX.peek(), startCacheY.peek(),
                    usedWidth = width >> zoom,  usedHeight = height >> zoom,
                    landModifier, heatModifier, cacheA, cacheB);
            rng.setState(cacheA, cacheB);
        }

    }
    /**
     * Floats the resolution of the map and halves the area it covers; the 2D arrays this uses keep their sizes. This
     * version of zoomIn always zooms in to the center of the currently used area.
     * <br>
     * Although there is no technical restriction on maximum zoom, zooming in more than 5 times (64x scale or greater)
     * will make the map appear somewhat less realistic due to rounded shapes appearing more bubble-like and less like a
     * normal landscape.
     */
    public void zoomIn()
    {
        zoomIn(1, width >> 1, height >> 1);
    }
    /**
     * Floats the resolution of the map and halves the area it covers repeatedly, doubling {@code zoomAmount} times;
     * the 2D arrays this uses keep their sizes. This version of zoomIn allows you to specify where the zoom should be
     * centered, using the current coordinates (if the map size is 256x256, then coordinates should be between 0 and
     * 255, and will refer to the currently used area and not necessarily the full world size).
     * <br>
     * Although there is no technical restriction on maximum zoom, zooming in more than 5 times (64x scale or greater)
     * will make the map appear somewhat less realistic due to rounded shapes appearing more bubble-like and less like a
     * normal landscape.
     * @param zoomCenterX the center X position to zoom in to; if too close to an edge, this will stop moving before it would extend past an edge
     * @param zoomCenterY the center Y position to zoom in to; if too close to an edge, this will stop moving before it would extend past an edge
     */
    public void zoomIn(int zoomAmount, int zoomCenterX, int zoomCenterY)
    {
        if(zoomAmount == 0) return;
        if(zoomAmount < 0)
        {
            zoomOut(-zoomAmount, zoomCenterX, zoomCenterY);
            return;
        }
        if(seedA != cacheA || seedB != cacheB)
        {
            generate(rng.nextLong(), rng.nextLong() | 1L);
        }
        zoomStartX = Math.min(Math.max(
                (zoomStartX + zoomCenterX - (width >> 1) << zoomAmount),
                width >> 1), (width << zoom + zoomAmount) - (width >> 1));
//        int oldZoomY = zoomStartY;
        zoomStartY = Math.min(Math.max(
                (zoomStartY + zoomCenterY - (height >> 1) << zoomAmount),
                height >> 1), (height << zoom + zoomAmount) - (height >> 1));
//        System.out.printf("zoomIn, zoomStartX: %d, zoomStartY: %d, oldZoomY: %d, unedited: %d, upperCap: %d\n", zoomStartX, zoomStartY,
//                oldZoomY, (oldZoomY + zoomCenterY - (height >> 1) << zoomAmount), (height << zoom + zoomAmount) - (height >> 1));
        zoom += zoomAmount;
        if(startCacheX.isEmpty())
        {
            startCacheX.add(0);
            startCacheY.add(0);
        }
        else {
            startCacheX.add(Math.min(Math.max(startCacheX.peek() + (zoomCenterX >> zoom - 1) - (width >> zoom + 1),
                    0), width - (width >> zoom)));
            startCacheY.add(Math.min(Math.max(startCacheY.peek() + (zoomCenterY >> zoom - 1) - (height >> zoom + 1),
                    0), height - (height >> zoom)));
        }
        regenerate(startX = (zoomStartX >> zoom) - (width >> 1 + zoom), startY = (zoomStartY >> zoom) - (height >> 1 + zoom),
                //startCacheX.peek(), startCacheY.peek(),
                usedWidth = width >> zoom, usedHeight = height >> zoom,
                landModifier, heatModifier, cacheA, cacheB);
        rng.setState(cacheA, cacheB);
    }

    protected abstract void regenerate(int startX, int startY, int usedWidth, int usedHeight,
                                       float landMod, float heatMod, long stateA, long stateB);
    /**
     * Given a latitude and longitude in radians (the conventional way of describing points on a globe), this gets the
     * (x,y) Coord on the map projection this generator uses that corresponds to the given lat-lon coordinates. If this
     * generator does not represent a globe (if it is toroidal, for instance) or if there is no "good way" to calculate
     * the projection for a given lat-lon coordinate, this returns null. The default implementation always returns null.
     * If this is a supported operation and the parameters are valid, this returns a Coord with x between 0 and
     * {@link #width}, and y between 0 and {@link #height}, both exclusive. Automatically wraps the Coord's values using
     * {@link #wrapX(int, int)} and {@link #wrapY(int, int)}.
     * @param latitude the latitude, from {@code -TrigTools.HALF_PI} to {@code TrigTools.HALF_PI}
     * @param longitude the longitude, from {@code 0f} to {@code TrigTools.PI2}
     * @return the point at the given latitude and longitude, as a Coord with x between 0 and {@link #width} and y between 0 and {@link #height}, or null if unsupported
     */
    public Coord project(float latitude, float longitude)
    {
        return null;
    }

    public int codeHeight(final float high)
    {
        if(high < deepWaterUpper)
            return 0;
        if(high < mediumWaterUpper)
            return 1;
        if(high < shallowWaterUpper)
            return 2;
        if(high < coastalWaterUpper)
            return 3;
        if(high < sandUpper)
            return 4;
        if(high < grassUpper)
            return 5;
        if(high < forestUpper)
            return 6;
        if(high < rockUpper)
            return 7;
        return 8;
    }
    public int wrapX(final int x, final int y)  {
        return (x + width) % width;
    }
    public int wrapY(final int x, final int y)  {
        return (y + height) % height;
    }

}
